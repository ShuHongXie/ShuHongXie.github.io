{"title":"前端错误上报流程：从拦截到上报的全解析","uid":"262476a3e53caf863c4dd5f0089e3fc0","slug":"一文读懂前端错误上报流程：从拦截到上报的全解析","date":"2025-05-19T16:00:00.000Z","updated":"2026-01-27T02:47:34.124Z","comments":true,"path":"api/articles/一文读懂前端错误上报流程：从拦截到上报的全解析.json","keywords":"谢小谢的博客，前端开发，Vue，Node.js","cover":"https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/dbd1.jpg","content":"<p>在前端开发中，用户在浏览器里踩的坑（比如页面突然白屏、按钮点了没反应），往往像“幽灵”一样没法实时复现。而前端错误上报机制，就像一位尽职的“前端侦探”，能自动捕捉这些报错、整理好线索发给后端，帮开发者快速锁定问题根源。下面结合实际代码，用大白话拆解这套上报流程的来龙去脉。</p>\n<h2 id=\"一、核心目标：精准、高效、低负担\"><a href=\"#一、核心目标：精准、高效、低负担\" class=\"headerlink\" title=\"一、核心目标：精准、高效、低负担\"></a>一、核心目标：精准、高效、低负担</h2><p>靠谱的错误上报可不是“抓到错误就乱发”，核心要拿捏好三个关键点：</p>\n<ul>\n<li><p><strong>精准性</strong>：过滤无效错误，只上报能帮开发者定位问题的有效信息，避免垃圾数据干扰。</p>\n</li>\n<li><p><strong>高效性</strong>：避免同一错误反复上报，同时控制上报频率，不给服务器和浏览器造成额外压力。</p>\n</li>\n<li><p><strong>完整性</strong>：上报信息要包含错误详情、浏览器环境等，方便开发者复现问题。</p>\n</li>\n</ul>\n<p>咱们接下来讲的流程，就围绕这三个目标设计。话不多说，直接从“错误被捕捉到”开始唠起～</p>\n<h2 id=\"二、完整上报流程：五步层层筛选-批量发送\"><a href=\"#二、完整上报流程：五步层层筛选-批量发送\" class=\"headerlink\" title=\"二、完整上报流程：五步层层筛选+批量发送\"></a>二、完整上报流程：五步层层筛选+批量发送</h2><p>当页面触发错误（比如语法写错、接口请求挂了），就会进入统一的上报入口。经过五层“层层筛选”，最后符合条件的错误才会被批量打包发给后端，效率拉满。</p>\n<h3 id=\"第一步：过滤无效错误——排除“无关干扰项”\"><a href=\"#第一步：过滤无效错误——排除“无关干扰项”\" class=\"headerlink\" title=\"第一步：过滤无效错误——排除“无关干扰项”\"></a>第一步：过滤无效错误——排除“无关干扰项”</h3><p>这一步就像安检的初筛，先把明显“无关紧要”的错误拦在门外，减轻后续流程的负担。主要筛掉三类“噪音错误”：</p>\n<ol>\n<li><p><strong>跨域脚本错误</strong>：页面引了其他域名的脚本，报错只显示“Script error.”，这种“无头案”没法定位，直接pass。</p>\n</li>\n<li><p><strong>第三方库错误</strong>：百度统计、谷歌分析这类第三方脚本的报错，跟咱们自己的业务代码没关系，犯不着上报。</p>\n</li>\n<li><p><strong>已知无害错误</strong>：像“ResizeObserver loop limit exceeded”这种浏览器兼容性提示，不影响页面功能，早早就被列入“白名单”忽略掉。</p>\n</li>\n</ol>\n<p>筛完这一轮，剩下的就都是“大概率和业务代码相关”的有效错误了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 过滤无效错误（跨域、第三方、已知无害错误）</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> errorData 错误数据</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@returns</span> true=有效（保留），false=无效（过滤）</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">filterInvalidError</span>(<span class=\"params\">errorData: Record&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">any</span>&gt;</span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> message = errorData.<span class=\"property\">message</span> || <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 1. 过滤跨域Script error</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (message.<span class=\"title function_\">includes</span>(<span class=\"string\">&quot;Script error.&quot;</span>)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 2. 过滤第三方库错误（如百度统计、广告脚本）</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (</span><br><span class=\"line\">    errorData.<span class=\"property\">fileName</span> &amp;&amp;</span><br><span class=\"line\">    (errorData.<span class=\"property\">fileName</span>.<span class=\"title function_\">includes</span>(<span class=\"string\">&quot;baidu.com&quot;</span>) ||</span><br><span class=\"line\">      errorData.<span class=\"property\">fileName</span>.<span class=\"title function_\">includes</span>(<span class=\"string\">&quot;google-analytics.com&quot;</span>))</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 3. 过滤已知无害错误</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> harmlessErrors = [</span><br><span class=\"line\">    <span class=\"string\">&quot;ResizeObserver loop limit exceeded&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;requestIdleCallback is not defined&quot;</span>,</span><br><span class=\"line\">  ];</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (harmlessErrors.<span class=\"title function_\">some</span>(<span class=\"function\">(<span class=\"params\">keyword</span>) =&gt;</span> message.<span class=\"title function_\">includes</span>(keyword))) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 4. 其他有效错误保留</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码就是过滤逻辑的“核心过滤器”，靠字符串匹配精准拦下三类无效错误，只让真正有价值的错误进入下一关。</p>\n<h3 id=\"第二步：去重校验——拒绝“重复轰炸”\"><a href=\"#第二步：去重校验——拒绝“重复轰炸”\" class=\"headerlink\" title=\"第二步：去重校验——拒绝“重复轰炸”\"></a>第二步：去重校验——拒绝“重复轰炸”</h3><p>同一错误可能在短时间内反复蹦出来（比如循环里的报错），要是每条都上报，不仅给服务器添负担，还会产生一堆垃圾数据。这一步的核心思路，就是给每个错误贴个“专属身份证”：</p>\n<ol>\n<li><p>根据错误消息、堆栈轨迹这些核心信息，生成一个唯一标识（相当于错误的“身份证号”）。</p>\n</li>\n<li><p>用一个“缓存容器”记下来已上报的错误和时间戳，还会定期清理30秒前的过期缓存，避免占内存。</p>\n</li>\n<li><p>如果当前错误的“身份证”在缓存里且没过期，说明是重复报错，直接拦下来；反之就放行。</p>\n</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 检查错误是否重复（去重逻辑）</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> errorData 错误数据</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@returns</span> true=重复（拦截），false=不重复（保留）</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">isDuplicateError</span>(<span class=\"params\">errorData: Record&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">any</span>&gt;</span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> key = <span class=\"title function_\">generateErrorKey</span>(errorData);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> cacheItem = errorCache.<span class=\"title function_\">get</span>(key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">cleanExpiredCache</span>(); <span class=\"comment\">// 每次检查都清理过期缓存，避免内存泄漏</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> !!(cacheItem &amp;&amp; <span class=\"title class_\">Date</span>.<span class=\"title function_\">now</span>() - cacheItem.<span class=\"property\">timestamp</span> &lt; <span class=\"variable constant_\">CONFIG</span>.<span class=\"property\">cacheExpire</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 生成错误的唯一标识（基于错误核心信息的哈希）</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">generateErrorKey</span>(<span class=\"params\">errorData: Record&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">any</span>&gt;</span>): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 提取错误核心特征：消息+堆栈（保证同类型错误生成相同key）</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> keyStr = <span class=\"string\">`<span class=\"subst\">$&#123;errorData.message || <span class=\"string\">&quot;&quot;</span>&#125;</span>-<span class=\"subst\">$&#123;errorData.stack || <span class=\"string\">&quot;&quot;</span>&#125;</span>`</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 简单哈希生成唯一标识（生产环境可替换为md5）</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">TextEncoder</span>().<span class=\"title function_\">encode</span>(keyStr))</span><br><span class=\"line\">    .<span class=\"title function_\">reduce</span>(<span class=\"function\">(<span class=\"params\">hash, char</span>) =&gt;</span> (hash &lt;&lt; <span class=\"number\">5</span>) - hash + char, <span class=\"number\">0</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">toString</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码一边给错误绑“身份证”做缓存，一边每次校验时清理过期数据，既解决了重复上报问题，又避免了内存浪费，一举两得。</p>\n<h3 id=\"第三步：节流控制——给上报“踩脚刹车”\"><a href=\"#第三步：节流控制——给上报“踩脚刹车”\" class=\"headerlink\" title=\"第三步：节流控制——给上报“踩脚刹车”\"></a>第三步：节流控制——给上报“踩脚刹车”</h3><p>极端情况下，页面可能短时间内爆一大堆错误（比如接口全挂了），这时候就得给上报“踩脚刹车”，不然服务器可能被冲垮。这一步就像路口的交通管制，有序放行：</p>\n<ol>\n<li><p>默认设置5秒的“时间窗口”，窗口内最多上报10条错误。</p>\n</li>\n<li><p>类型错误、网络错误这种关键报错，不受限制直接放行——核心问题可不能漏报。</p>\n</li>\n<li><p>非关键错误在时间窗口内计数，超过10条就拦截并提示，等窗口重置后再恢复上报。</p>\n</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 节流控制：限制单位时间内的上报次数</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> errorData 错误数据</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@returns</span> true=允许上报，false=拦截</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">checkThrottle</span>(<span class=\"params\">errorData: Record&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">any</span>&gt;</span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> message = errorData.<span class=\"property\">message</span> || <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 关键错误直接放行（不受节流限制）</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> isCritical = <span class=\"variable constant_\">CONFIG</span>.<span class=\"property\">throttle</span>.<span class=\"property\">criticalErrors</span>.<span class=\"title function_\">some</span>(<span class=\"function\">(<span class=\"params\">keyword</span>) =&gt;</span></span><br><span class=\"line\">    message.<span class=\"title function_\">includes</span>(keyword),</span><br><span class=\"line\">  );</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isCritical) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 初始化/重置节流定时器（5秒后重置计数）</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!throttleTimer) &#123;</span><br><span class=\"line\">    throttleTimer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      throttleCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">      throttleTimer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;, <span class=\"variable constant_\">CONFIG</span>.<span class=\"property\">throttle</span>.<span class=\"property\">windowTime</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 超出阈值则拦截并提示</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (throttleCount &gt;= <span class=\"variable constant_\">CONFIG</span>.<span class=\"property\">throttle</span>.<span class=\"property\">maxCount</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">warn</span>(</span><br><span class=\"line\">      <span class=\"string\">`[错误上报节流] 5秒内已上报<span class=\"subst\">$&#123;CONFIG.throttle.maxCount&#125;</span>条，本次拦截`</span>,</span><br><span class=\"line\">      errorData.<span class=\"property\">message</span>,</span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  throttleCount++;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定时器和计数变量搭配合作，就能实现时间窗口内的流量控制，既不耽误核心问题上报，又能保护服务器不被海量报错冲垮。</p>\n<h3 id=\"第四步：采样控制——高流量下“按需放行”\"><a href=\"#第四步：采样控制——高流量下“按需放行”\" class=\"headerlink\" title=\"第四步：采样控制——高流量下“按需放行”\"></a>第四步：采样控制——高流量下“按需放行”</h3><p>要是项目有百万级日活，哪怕经过前面几轮筛选，上报量依然可能很大。采样控制就像“智能闸门”，按比例放行报错，平衡好“问题覆盖”和“服务器压力”：</p>\n<ol>\n<li><p>关键错误依然全额上报，不参与采样。</p>\n</li>\n<li><p>非关键错误按预设采样率（默认40%）随机筛选——相当于100条错误里挑40条上报，既能反映问题分布，又能大幅降低服务器压力。</p>\n</li>\n<li><p>采样率还能动态调整：高流量时段调低，低峰时段调高，灵活适配不同业务场景。</p>\n</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 采样控制：按比例上报（高流量场景降低压力）</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> errorData 错误数据</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@returns</span> true=上报，false=拦截</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">checkSample</span>(<span class=\"params\">errorData: Record&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">any</span>&gt;</span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> message = errorData.<span class=\"property\">message</span> || <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 关键错误不受采样限制，全额上报</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> isCritical = <span class=\"variable constant_\">CONFIG</span>.<span class=\"property\">throttle</span>.<span class=\"property\">criticalErrors</span>.<span class=\"title function_\">some</span>(<span class=\"function\">(<span class=\"params\">keyword</span>) =&gt;</span></span><br><span class=\"line\">    message.<span class=\"title function_\">includes</span>(keyword),</span><br><span class=\"line\">  );</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isCritical) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 随机数判断是否命中采样率（0.4即40%概率上报）</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> ramdomRate = <span class=\"title class_\">Math</span>.<span class=\"title function_\">random</span>();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ramdomRate &lt;= <span class=\"variable constant_\">CONFIG</span>.<span class=\"property\">sampleRate</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>靠随机数和采样率对比实现比例筛选，既不会错过关键问题，又能给服务器“减负”，堪称高流量场景的神器。</p>\n<h3 id=\"第五步：批量上报——攒够一波再“发车”\"><a href=\"#第五步：批量上报——攒够一波再“发车”\" class=\"headerlink\" title=\"第五步：批量上报——攒够一波再“发车”\"></a>第五步：批量上报——攒够一波再“发车”</h3><p>经过前面四轮“层层筛选”，剩下的都是“高质量、有价值”的错误。批量上报的思路很简单：不一条一条发，攒够一波再“发车”，减少网络请求次数、提升性能。</p>\n<ol>\n<li><p>用一个队列存通过筛选的错误，同时启动5秒定时器。</p>\n</li>\n<li><p>满足两个条件之一就“发车”：队列满10条，或者5秒定时器到点——避免队列长期不满导致报错信息延迟。</p>\n</li>\n<li><p>上报前还会自动补充浏览器版本、系统类型这些信息，给后端多添点线索；发送时优先用更可靠的方式，失败了就自动降级，确保报错信息能成功送达。</p>\n</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 批量上报核心方法</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> errors 批量错误数据</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> url 上报接口地址</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sendBatchErrorData</span>(<span class=\"params\">errors: Record&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">any</span>&gt;[], url: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (errors.<span class=\"property\">length</span> === <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 合并浏览器信息，补充上下文</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> browserInfo = <span class=\"title function_\">getBrowserInfo</span>();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dataToSend = errors.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> (&#123; ...error, ...browserInfo &#125;));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 优先用sendBeacon，失败降级为fetch（保障页面卸载时也能发送）</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (navigator.<span class=\"property\">sendBeacon</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> blob = <span class=\"keyword\">new</span> <span class=\"title class_\">Blob</span>([<span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(dataToSend)], &#123;</span><br><span class=\"line\">      <span class=\"attr\">type</span>: <span class=\"string\">&quot;application/json&quot;</span>,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    navigator.<span class=\"title function_\">sendBeacon</span>(url, blob);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">fetch</span>(url, &#123;</span><br><span class=\"line\">      <span class=\"attr\">method</span>: <span class=\"string\">&quot;POST&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">headers</span>: &#123; <span class=\"string\">&quot;Content-Type&quot;</span>: <span class=\"string\">&quot;application/json&quot;</span> &#125;,</span><br><span class=\"line\">      <span class=\"attr\">body</span>: <span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(dataToSend),</span><br><span class=\"line\">      <span class=\"attr\">keepalive</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    &#125;).<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&quot;批量上报失败:&quot;</span>, error));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 触发批量上报（清空队列并发送）</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">triggerBatchReport</span>(<span class=\"params\">url: <span class=\"built_in\">string</span></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (errorBatchQueue.<span class=\"property\">length</span> === <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> errorsToSend = [...errorBatchQueue];</span><br><span class=\"line\">  errorBatchQueue.<span class=\"property\">length</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (batchTimer) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">clearTimeout</span>(batchTimer);</span><br><span class=\"line\">    batchTimer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">sendBatchErrorData</span>(errorsToSend, url);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>队列存错、定时器触发、双方式降级发送，这套组合拳既减少了网络请求，又保障了上报的可靠性，性价比拉满。</p>\n<h2 id=\"三、额外保障：内存泄漏防护\"><a href=\"#三、额外保障：内存泄漏防护\" class=\"headerlink\" title=\"三、额外保障：内存泄漏防护\"></a>三、额外保障：内存泄漏防护</h2><p>错误上报机制自己可不能掉链子，内存泄漏就是重点防护对象。代码里做了两处“防护措施”，从源头规避问题：</p>\n<ol>\n<li><p>页面卸载前（比如用户关标签页），清理所有定时器、清空错误队列和缓存，不让残留资源占内存。</p>\n</li>\n<li><p>定期清理过期缓存，防止缓存越积越大，拖慢浏览器速度。</p>\n</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 清理所有定时器，防止内存泄漏</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">cleanupTimers</span>(<span class=\"params\"></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (throttleTimer) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">clearTimeout</span>(throttleTimer);</span><br><span class=\"line\">    throttleTimer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (batchTimer) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">clearTimeout</span>(batchTimer);</span><br><span class=\"line\">    batchTimer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  errorBatchQueue.<span class=\"property\">length</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">  errorCache.<span class=\"title function_\">clear</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 页面卸载前执行清理，避免残留资源</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"variable language_\">window</span> !== <span class=\"string\">&quot;undefined&quot;</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">window</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&quot;beforeunload&quot;</span>, cleanupTimers);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>靠页面卸载事件绑定清理函数，把定时器、队列、缓存这些资源彻底释放，从根源上杜绝内存泄漏的隐患。</p>\n<h2 id=\"四、总结：错误上报的核心逻辑\"><a href=\"#四、总结：错误上报的核心逻辑\" class=\"headerlink\" title=\"四、总结：错误上报的核心逻辑\"></a>四、总结：错误上报的核心逻辑</h2><p>总结下来，前端错误上报流程就是一套“层层筛选、按需控制、高效发送”的闭环操作。从筛掉无效错误减少干扰，到去重、节流、采样控制上报量，再到批量发送优化性能，每一步都围绕“精准上报、低耗运行”发力。这套机制既能帮开发者快速定位问题，又不影响用户体验、不增加服务器负担，妥妥的前端质量监控“守护神”。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>（注：文档部分内容可能由 AI 生成）</p></blockquote>\n","text":"在前端开发中，用户在浏览器里踩的坑（比如页面突然白屏、按钮点了没反应），往往像“幽灵”一样没法实时复现。而前端错误上报机制，就像一位尽职的“前端侦探”，能自动捕...","permalink":"/post/一文读懂前端错误上报流程：从拦截到上报的全解析","photos":[],"count_time":{"symbolsCount":"7.1k","symbolsTime":"6 mins."},"categories":[{"name":"uni-app","slug":"uni-app","count":4,"path":"api/categories/uni-app.json"}],"tags":[{"name":"前端错误上报","slug":"前端错误上报","count":1,"path":"api/tags/前端错误上报.json"},{"name":"前端监控","slug":"前端监控","count":1,"path":"api/tags/前端监控.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E6%A0%B8%E5%BF%83%E7%9B%AE%E6%A0%87%EF%BC%9A%E7%B2%BE%E5%87%86%E3%80%81%E9%AB%98%E6%95%88%E3%80%81%E4%BD%8E%E8%B4%9F%E6%8B%85\"><span class=\"toc-text\">一、核心目标：精准、高效、低负担</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E5%AE%8C%E6%95%B4%E4%B8%8A%E6%8A%A5%E6%B5%81%E7%A8%8B%EF%BC%9A%E4%BA%94%E6%AD%A5%E5%B1%82%E5%B1%82%E7%AD%9B%E9%80%89-%E6%89%B9%E9%87%8F%E5%8F%91%E9%80%81\"><span class=\"toc-text\">二、完整上报流程：五步层层筛选+批量发送</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E8%BF%87%E6%BB%A4%E6%97%A0%E6%95%88%E9%94%99%E8%AF%AF%E2%80%94%E2%80%94%E6%8E%92%E9%99%A4%E2%80%9C%E6%97%A0%E5%85%B3%E5%B9%B2%E6%89%B0%E9%A1%B9%E2%80%9D\"><span class=\"toc-text\">第一步：过滤无效错误——排除“无关干扰项”</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E5%8E%BB%E9%87%8D%E6%A0%A1%E9%AA%8C%E2%80%94%E2%80%94%E6%8B%92%E7%BB%9D%E2%80%9C%E9%87%8D%E5%A4%8D%E8%BD%B0%E7%82%B8%E2%80%9D\"><span class=\"toc-text\">第二步：去重校验——拒绝“重复轰炸”</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E8%8A%82%E6%B5%81%E6%8E%A7%E5%88%B6%E2%80%94%E2%80%94%E7%BB%99%E4%B8%8A%E6%8A%A5%E2%80%9C%E8%B8%A9%E8%84%9A%E5%88%B9%E8%BD%A6%E2%80%9D\"><span class=\"toc-text\">第三步：节流控制——给上报“踩脚刹车”</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%9A%E9%87%87%E6%A0%B7%E6%8E%A7%E5%88%B6%E2%80%94%E2%80%94%E9%AB%98%E6%B5%81%E9%87%8F%E4%B8%8B%E2%80%9C%E6%8C%89%E9%9C%80%E6%94%BE%E8%A1%8C%E2%80%9D\"><span class=\"toc-text\">第四步：采样控制——高流量下“按需放行”</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%BA%94%E6%AD%A5%EF%BC%9A%E6%89%B9%E9%87%8F%E4%B8%8A%E6%8A%A5%E2%80%94%E2%80%94%E6%94%92%E5%A4%9F%E4%B8%80%E6%B3%A2%E5%86%8D%E2%80%9C%E5%8F%91%E8%BD%A6%E2%80%9D\"><span class=\"toc-text\">第五步：批量上报——攒够一波再“发车”</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E9%A2%9D%E5%A4%96%E4%BF%9D%E9%9A%9C%EF%BC%9A%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%98%B2%E6%8A%A4\"><span class=\"toc-text\">三、额外保障：内存泄漏防护</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93%EF%BC%9A%E9%94%99%E8%AF%AF%E4%B8%8A%E6%8A%A5%E7%9A%84%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91\"><span class=\"toc-text\">四、总结：错误上报的核心逻辑</span></a></li></ol>","author":{"name":"谢小谢","slug":"blog-author","avatar":"https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/logo24.png","link":"/","description":"Love Music, love life","socials":{"github":"https://github.com/ShuHongXie","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"jenkins环境变量中英文对照表","uid":"c070cc3280800d8c94f2de83786567b7","slug":"jenkins环境变量中英文对照表","date":"2025-02-24T16:00:00.000Z","updated":"2026-01-26T07:52:16.063Z","comments":true,"path":"api/articles/jenkins环境变量中英文对照表.json","keywords":"谢小谢的博客，前端开发，Vue，Node.js","cover":"https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/blog/afc81aab47b184a378137072502c5d13.jpeg","text":"一、分支与变更相关变量 BRANCH_NAME：多分支项目中，指当前构建的分支名称。例如可用于仅从主分支部署生产环境，而非功能分支；若对应变更请求（如 PR），...","permalink":"/post/jenkins环境变量中英文对照表","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"Jenkins","slug":"Jenkins","count":1,"path":"api/categories/Jenkins.json"}],"tags":[{"name":"Jenkins","slug":"Jenkins","count":1,"path":"api/tags/Jenkins.json"},{"name":"自动化构建","slug":"自动化构建","count":1,"path":"api/tags/自动化构建.json"}],"author":{"name":"谢小谢","slug":"blog-author","avatar":"https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/logo24.png","link":"/","description":"Love Music, love life","socials":{"github":"https://github.com/ShuHongXie","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Vite中Pinia多实例问题及解决方案","uid":"6454991adcd7885c39f198934a9d7391","slug":"Vite中Pinia多实例问题及解决方案","date":"2025-02-09T16:00:00.000Z","updated":"2026-01-26T07:48:53.558Z","comments":true,"path":"api/articles/Vite中Pinia多实例问题及解决方案.json","keywords":"谢小谢的博客，前端开发，Vue，Node.js","cover":"https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/blog/wechat_2026-01-26_154717_224.png","text":"一、问题概述在 Vite 构建的项目中，若 Pinia 被多次打包，会创建多个独立的 Pinia 模块实例，导致 Store 定义与使用时引用不同实例，最终出现...","permalink":"/post/Vite中Pinia多实例问题及解决方案","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"Vue3","slug":"Vue3","count":1,"path":"api/categories/Vue3.json"}],"tags":[{"name":"Pinia","slug":"Pinia","count":1,"path":"api/tags/Pinia.json"},{"name":"错误定位","slug":"错误定位","count":1,"path":"api/tags/错误定位.json"}],"author":{"name":"谢小谢","slug":"blog-author","avatar":"https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/logo24.png","link":"/","description":"Love Music, love life","socials":{"github":"https://github.com/ShuHongXie","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}