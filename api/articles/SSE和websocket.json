{"title":"SSE技术和websocket","uid":"7a8ea0bc07f9bbaa57fab7575f0fd41d","slug":"SSE和websocket","date":"2024-04-13T16:00:00.000Z","updated":"2025-01-10T02:38:45.427Z","comments":true,"path":"api/articles/SSE和websocket.json","keywords":"谢小谢的博客，前端开发，Vue，Node.js","cover":"https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202501101036873.png","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>随着 chatgpt3，4 版本的推出，AI 应用的崛起态势已非常明显，当我看到 AI 应用回答我提问的时候，我非常好奇 AI 应用是如何做到不卡的，毕竟有那么多文字，如果一个一个轮询的话效率会非常慢，需要频繁请求。于是我搜了搜相关技术，发现了 SSE 这个服务器主动推送的东西，这不免让我想到了 Websocket。那这两者有什么区别呢？</p>\n<h3 id=\"SSE-流式传输\"><a href=\"#SSE-流式传输\" class=\"headerlink\" title=\"SSE 流式传输\"></a><strong>SSE 流式传输</strong></h3><p>如标题所言，通过 SSE 流式传输的方式可以让我们不再通过轮询的方式获取服务端返回的结果，进而提升前端页面的性能。</p>\n<p>对于需要轮询的业务场景来说，采用 SSE 确实是一个更好的技术方案。接下来，我将 SSE 的概念、与 Websocket 对比、SSE 应用场景多个方面介绍 SSE 流式传输</p>\n<h3 id=\"什么是-SSE-流式传输\"><a href=\"#什么是-SSE-流式传输\" class=\"headerlink\" title=\"什么是 SSE 流式传输\"></a>什么是 SSE 流式传输</h3><p>SSE 全称为  <strong>Server-sent events</strong> , 是一种基于 HTTP 协议的通信技术，允许服务器主动向客户端（通常是 Web 浏览器）发送更新。</p>\n<p>它是 HTML5 标准的一部分，设计初衷是用来建立一个单向的服务器到客户端连接，使得服务器可以实时地向客户端发送数据。</p>\n<p><strong>这种服务端实时向客户端发送数据的传输方式，其实就是流式传输。</strong></p>\n<p>因为我经常使用字节跳动的 AI 应用“豆包”的原因，可以发现豆包的响应总是间断完成。细扒豆包的网络传输模式，可以发现，用的也是流式传输。</p>\n<p><img src=\"https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202501101018558.png\"></p>\n<h3 id=\"SSE-流式传输的好处\"><a href=\"#SSE-流式传输的好处\" class=\"headerlink\" title=\"SSE 流式传输的好处\"></a>SSE 流式传输的好处</h3><p>在  <strong>SSE</strong>  技术出现之前，我们习惯把需要等待服务端返回的过程称为长轮询。</p>\n<p>长轮询的实现其实也是借助 http 请求来完成，一个完整的长轮询过程如下图所示：</p>\n<p><img src=\"https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202501101021822.png\"></p>\n<p>从图中可以发现，<strong>长轮询最大的弊端是当服务端响应请求之前，客户端发送的所有请求都不会被受理。并且服务端发送响应的前提是客户端发起请求。</strong></p>\n<p>前后端通信过程中，我们常采用 ajax 、axios 来异步获取结果，这个过程，其实也是长轮询的过程。</p>\n<p>而同为采用 http 协议通信方式的 SSE 流式传输，相比于长轮询模式来说，优势在于可以在不需要客户端介入的情况下，多次向客户端发送响应，直至客户端关闭连接。</p>\n<p>这对于需要服务端实时推送内容至客户端的场景可方便太多了！</p>\n<h3 id=\"SSE-技术原理\"><a href=\"#SSE-技术原理\" class=\"headerlink\" title=\"SSE 技术原理\"></a>SSE 技术原理</h3><h6 id=\"1-参数设置\"><a href=\"#1-参数设置\" class=\"headerlink\" title=\"1. 参数设置\"></a>1. 参数设置</h6><p>前文说到，SSE 本质是一个基于 http 协议的通信技术。</p>\n<p>因此想要使用  <strong>SSE</strong>  技术构建需要服务器实时推送信息到客户端的连接，只需要将传统的  <strong>http 响应头的 contentType 设置为 text&#x2F;event-stream</strong> 。</p>\n<p>并且为了保证客户端展示的是最新数据，需要将  <strong>Cache-Control 设置为 no-cache</strong> 。</p>\n<p>在此基础上，<strong>SSE</strong>  本质是一个 TCP 连接，因此为了保证 SSE 的持续开启，需要将  <strong>Connection 设置为 keep-alive</strong> 。</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Content-Type</span>: text/event-stream</span><br><span class=\"line\"><span class=\"attribute\">Cache-Control</span>: no-cache</span><br><span class=\"line\"><span class=\"attribute\">Connection</span>: keep-alive</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>完成了上述响应头的设置后，我们可以编写一个基于  <strong>SSE</strong>  流式传输的简单 Demo 。</p>\n<h6 id=\"2-SSE-Demo\"><a href=\"#2-SSE-Demo\" class=\"headerlink\" title=\"2. SSE Demo\"></a>2. SSE Demo</h6><p>服务端代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;express&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"title function_\">express</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">PORT</span> = <span class=\"number\">3000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"title function_\">use</span>(express.<span class=\"title function_\">static</span>(<span class=\"string\">&quot;public&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"title function_\">get</span>(<span class=\"string\">&quot;/events&quot;</span>, <span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) &#123;</span><br><span class=\"line\">  res.<span class=\"title function_\">setHeader</span>(<span class=\"string\">&quot;Content-Type&quot;</span>, <span class=\"string\">&quot;text/event-stream&quot;</span>);</span><br><span class=\"line\">  res.<span class=\"title function_\">setHeader</span>(<span class=\"string\">&quot;Cache-Control&quot;</span>, <span class=\"string\">&quot;no-cache&quot;</span>);</span><br><span class=\"line\">  res.<span class=\"title function_\">setHeader</span>(<span class=\"string\">&quot;Connection&quot;</span>, <span class=\"string\">&quot;keep-alive&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> startTime = <span class=\"title class_\">Date</span>.<span class=\"title function_\">now</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">sendEvent</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 检查是否已经发送了10秒</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"title class_\">Date</span>.<span class=\"title function_\">now</span>() - startTime &gt;= <span class=\"number\">10000</span>) &#123;</span><br><span class=\"line\">      res.<span class=\"title function_\">write</span>(<span class=\"string\">&quot;event: close\\ndata: &#123;&#125;\\n\\n&quot;</span>); <span class=\"comment\">// 发送一个特殊事件通知客户端关闭</span></span><br><span class=\"line\">      res.<span class=\"title function_\">end</span>(); <span class=\"comment\">// 关闭连接</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = &#123; <span class=\"attr\">message</span>: <span class=\"string\">&quot;Hello World&quot;</span>, <span class=\"attr\">timestamp</span>: <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>() &#125;;</span><br><span class=\"line\">    res.<span class=\"title function_\">write</span>(<span class=\"string\">`data: <span class=\"subst\">$&#123;<span class=\"built_in\">JSON</span>.stringify(data)&#125;</span>\\n\\n`</span>); <span class=\"comment\">// 每隔2秒发送一次消息</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(sendEvent, <span class=\"number\">2000</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">sendEvent</span>();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"title function_\">listen</span>(<span class=\"variable constant_\">PORT</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Server running on http://localhost:<span class=\"subst\">$&#123;PORT&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>客户端代码：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>SSE Example<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Server-Sent Events Example<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;messages&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">const</span> evtSource = <span class=\"keyword\">new</span> <span class=\"title class_\">EventSource</span>(<span class=\"string\">&#x27;/events&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">const</span> messages = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;messages&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        evtSource.<span class=\"property\">onmessage</span> = <span class=\"keyword\">function</span>(<span class=\"params\">event</span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"keyword\">const</span> newElement = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&quot;p&quot;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"keyword\">const</span> eventObject = <span class=\"title class_\">JSON</span>.<span class=\"title function_\">parse</span>(event.<span class=\"property\">data</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">            newElement.<span class=\"property\">textContent</span> = <span class=\"string\">&quot;Message: &quot;</span> + eventObject.<span class=\"property\">message</span> + <span class=\"string\">&quot; at &quot;</span> + eventObject.<span class=\"property\">timestamp</span>;</span></span><br><span class=\"line\"><span class=\"language-javascript\">            messages.<span class=\"title function_\">appendChild</span>(newElement);</span></span><br><span class=\"line\"><span class=\"language-javascript\">        &#125;;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>当我们在浏览器中访问运行在 localhost: 3000 端口的客户端页面时，页面将会以  <strong>流式模式</strong>  逐步渲染服务端返回的结果</p>\n<p>需要注意的是，为了保证使用  <strong>SSE</strong>  通信协议传输的数据能被客户端正确的接收，服务端和客户端在发送数据和接收数据应该遵循以下规范：</p>\n<h6 id=\"服务端基本响应格式\"><a href=\"#服务端基本响应格式\" class=\"headerlink\" title=\"服务端基本响应格式\"></a>服务端基本响应格式</h6><p><strong>SSE</strong>  响应主要由一系列以两个换行符分隔的事件组成。每个事件可以包含以下字段：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">data</span>：事件的数据。如果数据跨越多行，每行都应该以<span class=\"keyword\">data</span>:开始。</span><br><span class=\"line\">id：事件的唯一标识符。客户端可以使用这个ID来恢复事件流。</span><br><span class=\"line\">event：自定义事件类型。客户端可以根据不同的事件类型来执行不同的操作。</span><br><span class=\"line\">retry：建议的重新连接时间（毫秒）。如果连接中断，客户端将等待这段时间后尝试重新连接。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>字段之间用单个换行符分隔，而事件之间用两个换行符分隔。</p>\n<h6 id=\"客户端处理格式\"><a href=\"#客户端处理格式\" class=\"headerlink\" title=\"客户端处理格式\"></a>客户端处理格式</h6><p>客户端使用  <strong>EventSource</strong>  接口监听  <strong>SSE</strong>  消息：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const <span class=\"attr\">evtSource</span> = new EventSource(<span class=\"string\">&#x27;path/to/sse&#x27;</span>)<span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"attr\">evtSource.onmessage</span> = function(event) &#123;</span><br><span class=\"line\">    console.log(event.data)<span class=\"comment\">; // 处理收到的数据</span></span><br><span class=\"line\">&#125;<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"SSE-应用场景\"><a href=\"#SSE-应用场景\" class=\"headerlink\" title=\"SSE 应用场景\"></a>SSE 应用场景</h3><p><strong>SSE</strong>  作为基于  <strong>http</strong>  协议由服务端向客户端单向推送消息的通信技术，对于需要服务端主动推送消息的场景来说，是非常适合的</p>\n<ol>\n<li>AI 对话</li>\n<li>实时天气</li>\n<li>实时股票</li>\n</ol>\n<h3 id=\"SSE-兼容性\"><a href=\"#SSE-兼容性\" class=\"headerlink\" title=\"SSE 兼容性\"></a>SSE 兼容性</h3><p><img src=\"https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202501101027256.png\"></p>\n<p>可以发现，目前市面上绝大多数浏览器都支持  <strong>SSE</strong>  通信。</p>\n<h3 id=\"SSE-与-WebSocket-对比-h\"><a href=\"#SSE-与-WebSocket-对比-h\" class=\"headerlink\" title=\"SSE 与 WebSocket 对比 h\"></a>SSE 与 WebSocket 对比 h</h3><p>看完 SSE 的使用方式后，细心的同学应该发现了：</p>\n<p><strong>SSE</strong>  的通信方式和  <strong>WebSocket</strong>  很像啊，而且 WebSocket 还支持双向通信，为什么不直接使用 WebSocket ？</p>\n<p>对于这三者的详细区别，你可以参考下面我总结的表格：</p>\n<p>以下是 WebSocket、轮询和 SSE 的对比表格：</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>WebSocket</th>\n<th>轮询 Polling</th>\n<th>Server-Sent Events (SSE)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>定义</strong></td>\n<td>全双工通信协议，支持服务器和客户端之间的双向通信。</td>\n<td>客户端定期向服务器发送请求以检查更新。</td>\n<td>服务器向客户端推送数据的单向通信协议。</td>\n</tr>\n<tr>\n<td><strong>实时性</strong></td>\n<td>高，服务器可以主动推送数据。</td>\n<td>低，依赖客户端定时请求。</td>\n<td>高，服务器可以主动推送数据。</td>\n</tr>\n<tr>\n<td><strong>开销</strong></td>\n<td>相对较高，需要建立和维护持久连接。</td>\n<td>较低，但频繁请求可能导致高网络和服务器开销。</td>\n<td>相对较低，只需要一个 HTTP 连接，服务器推送数据。</td>\n</tr>\n<tr>\n<td><strong>浏览器支持</strong></td>\n<td>现代浏览器支持，需要额外的库来支持旧浏览器。</td>\n<td>所有浏览器支持。</td>\n<td>现代浏览器支持良好，旧浏览器可能需要 polyfill。</td>\n</tr>\n<tr>\n<td><strong>实现复杂性</strong></td>\n<td>高，需要处理连接的建立、维护和关闭。</td>\n<td>低，只需定期发送请求。</td>\n<td>中等，只需要处理服务器推送的数据。</td>\n</tr>\n<tr>\n<td><strong>数据格式</strong></td>\n<td>支持二进制和文本数据。</td>\n<td>通常为 JSON 或 XML。</td>\n<td>仅支持文本数据，通常为 JSON。</td>\n</tr>\n<tr>\n<td><strong>控制流</strong></td>\n<td>客户端和服务器都可以控制消息发送。</td>\n<td>客户端控制请求发送频率。</td>\n<td>服务器完全控制数据推送。</td>\n</tr>\n<tr>\n<td><strong>安全性</strong></td>\n<td>需要 wss:&#x2F;&#x2F;（WebSocket Secure）来保证安全。</td>\n<td>需要<a href=\"https://link.juejin.cn/?target=https://%25E6%259D%25A5%25E4%25BF%259D%25E8%25AF%2581%25E8%25AF%25B7%25E6%25B1%2582%25E7%259A%2584%25E5%25AE%2589%25E5%2585%25A8%25E3%2580%2582\" title=\"https://%E6%9D%A5%E4%BF%9D%E8%AF%81%E8%AF%B7%E6%B1%82%E7%9A%84%E5%AE%89%E5%85%A8%E3%80%82\">https:&#x2F;&#x2F;来保证请求的安全。</a></td>\n<td>需要 SSE 通过 HTTPS 提供，以保证数据传输的安全。</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>需要双向交互的应用，如聊天室、实时游戏。</td>\n<td>适用于更新频率不高的场景，如轮询邮箱。</td>\n<td>适用于服务器到客户端的单向数据流，如股票价格更新。</td>\n</tr>\n<tr>\n<td><strong>跨域限制</strong></td>\n<td>默认不支持跨域，需要服务器配置 CORS。</td>\n<td>默认不支持跨域，需要服务器配置 CORS。</td>\n<td>默认不支持跨域，需要服务器配置 CORS。</td>\n</tr>\n<tr>\n<td><strong>重连机制</strong></td>\n<td>客户端可以实现自动重连逻辑。</td>\n<td>需要客户端实现重连逻辑。</td>\n<td>客户端可以监听连接关闭并尝试重连。</td>\n</tr>\n<tr>\n<td><strong>服务器资源</strong></td>\n<td>较高，因为需要维护持久连接。</td>\n<td>较低，但频繁的请求可能增加服务器负担。</td>\n<td>较低，只需要维护一个 HTTP 连接。</td>\n</tr>\n</tbody></table>\n<p>这个表格概括了 WebSocket、轮询和 SSE 在不同特性上的主要对比点。每种技术都有其适用的场景和限制，选择合适的技术需要根据具体的应用需求来决定。<br>可以发现，<strong>SSE</strong>  与  <strong>WebSocket</strong>  各有优缺点，对于需要客户端与服务端高频交互的场景，WebSocket 确实更适合；但对于只需要服务端单向数据传输的场景，<strong>SSE 确实能耗更低，且不需要客户端感知</strong>。</p>\n","feature":true,"text":"前言随着 chatgpt3，4 版本的推出，AI 应用的崛起态势已非常明显，当我看到 AI 应用回答我提问的时候，我非常好奇 AI 应用是如何做到不卡的，毕竟有...","permalink":"/post/SSE和websocket","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[{"name":"总结","slug":"总结","count":2,"path":"api/categories/总结.json"}],"tags":[{"name":"http","slug":"http","count":5,"path":"api/tags/http.json"},{"name":"AI","slug":"AI","count":1,"path":"api/tags/AI.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SSE-%E6%B5%81%E5%BC%8F%E4%BC%A0%E8%BE%93\"><span class=\"toc-text\">SSE 流式传输</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF-SSE-%E6%B5%81%E5%BC%8F%E4%BC%A0%E8%BE%93\"><span class=\"toc-text\">什么是 SSE 流式传输</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SSE-%E6%B5%81%E5%BC%8F%E4%BC%A0%E8%BE%93%E7%9A%84%E5%A5%BD%E5%A4%84\"><span class=\"toc-text\">SSE 流式传输的好处</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SSE-%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">SSE 技术原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#1-%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE\"><span class=\"toc-text\">1. 参数设置</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#2-SSE-Demo\"><span class=\"toc-text\">2. SSE Demo</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%9F%BA%E6%9C%AC%E5%93%8D%E5%BA%94%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">服务端基本响应格式</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">客户端处理格式</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SSE-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">SSE 应用场景</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SSE-%E5%85%BC%E5%AE%B9%E6%80%A7\"><span class=\"toc-text\">SSE 兼容性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SSE-%E4%B8%8E-WebSocket-%E5%AF%B9%E6%AF%94-h\"><span class=\"toc-text\">SSE 与 WebSocket 对比 h</span></a></li></ol>","author":{"name":"谢小谢","slug":"blog-author","avatar":"https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/logo24.png","link":"/","description":"Love Music, love life","socials":{"github":"https://github.com/ShuHongXie","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"openapi搭配swagger实现自动化axios和TS结构生成","uid":"a5e1de8bcca72c1338dc7ea35c5a612c","slug":"openapi搭配swagger实现自动化axios","date":"2024-09-19T16:00:00.000Z","updated":"2025-01-10T03:45:39.033Z","comments":true,"path":"api/articles/openapi搭配swagger实现自动化axios.json","keywords":"谢小谢的博客，前端开发，Vue，Node.js","cover":"https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/202501101143898.png","text":"前言自从 vue3 版本推出之后，typescript 就进入了众多 vue 选手的视野，但是使用 axios 来请求时，往往会出现返回的结构体需要专门定义，且...","permalink":"/post/openapi搭配swagger实现自动化axios","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"经验","slug":"经验","count":7,"path":"api/categories/经验.json"}],"tags":[{"name":"axios","slug":"axios","count":1,"path":"api/tags/axios.json"},{"name":"openapi","slug":"openapi","count":1,"path":"api/tags/openapi.json"}],"author":{"name":"谢小谢","slug":"blog-author","avatar":"https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/logo24.png","link":"/","description":"Love Music, love life","socials":{"github":"https://github.com/ShuHongXie","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"记一次uni-app原生应用高德地图配置的坑","uid":"be8b20988d64ed90b36f55c5730a76e9","slug":"记一次uni-app原生应用高德地图配置的坑","date":"2023-11-15T16:00:00.000Z","updated":"2025-01-03T07:56:12.098Z","comments":true,"path":"api/articles/记一次uni-app原生应用高德地图配置的坑.json","keywords":"谢小谢的博客，前端开发，Vue，Node.js","cover":"https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/gddt.png","text":"前言为配合打荷生鲜 2.0 小程序的发展，需要对配送人员增加一个类似于美团骑手版的安卓 App，为此需要引入高德地图的 sdk，折腾了我一天的时候，为此将遇到的...","permalink":"/post/记一次uni-app原生应用高德地图配置的坑","photos":[],"count_time":{"symbolsCount":672,"symbolsTime":"1 mins."},"categories":[{"name":"经验","slug":"经验","count":7,"path":"api/categories/经验.json"}],"tags":[{"name":"原生小程序","slug":"原生小程序","count":2,"path":"api/tags/原生小程序.json"},{"name":"高德地图","slug":"高德地图","count":1,"path":"api/tags/高德地图.json"}],"author":{"name":"谢小谢","slug":"blog-author","avatar":"https://blog-1300014307.cos.ap-guangzhou.myqcloud.com/logo24.png","link":"/","description":"Love Music, love life","socials":{"github":"https://github.com/ShuHongXie","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}