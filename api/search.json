[{"id":"262476a3e53caf863c4dd5f0089e3fc0","title":"前端错误上报流程：从拦截到上报的全解析","content":"在前端开发中，用户在浏览器里踩的坑（比如页面突然白屏、按钮点了没反应），往往像“幽灵”一样没法实时复现。而前端错误上报机制，就像一位尽职的“前端侦探”，能自动捕捉这些报错、整理好线索发给后端，帮开发者快速锁定问题根源。下面结合实际代码，用大白话拆解这套上报流程的来龙去脉。\n一、核心目标：精准、高效、低负担靠谱的错误上报可不是“抓到错误就乱发”，核心要拿捏好三个关键点：\n\n精准性：过滤无效错误，只上报能帮开发者定位问题的有效信息，避免垃圾数据干扰。\n\n高效性：避免同一错误反复上报，同时控制上报频率，不给服务器和浏览器造成额外压力。\n\n完整性：上报信息要包含错误详情、浏览器环境等，方便开发者复现问题。\n\n\n咱们接下来讲的流程，就围绕这三个目标设计。话不多说，直接从“错误被捕捉到”开始唠起～\n二、完整上报流程：五步层层筛选+批量发送当页面触发错误（比如语法写错、接口请求挂了），就会进入统一的上报入口。经过五层“层层筛选”，最后符合条件的错误才会被批量打包发给后端，效率拉满。\n第一步：过滤无效错误这一步就像安检的初筛，先把明显“无关紧要”的错误拦在门外，减轻后续流程的负担。主要筛掉三类“噪音错误”：\n\n跨域脚本错误：页面引了其他域名的脚本，报错只显示“Script error.”，这种“无头案”没法定位，直接 pass。\n\n第三方库错误：百度统计、谷歌分析这类第三方脚本的报错，跟咱们自己的业务代码没关系，犯不着上报。\n\n已知无害错误：像“ResizeObserver loop limit exceeded”这种浏览器兼容性提示，不影响页面功能，早早就被列入“白名单”忽略掉。\n\n\n筛完这一轮，剩下的就都是“大概率和业务代码相关”的有效错误了。\n1234567891011121314151617181920212223242526/** * 过滤无效错误（跨域、第三方、已知无害错误） * @param errorData 错误数据 * @returns true=有效（保留），false=无效（过滤） */function filterInvalidError(errorData: Record&lt;string, any&gt;): boolean &#123;  const message = errorData.message || &quot;&quot;;  // 1. 过滤跨域Script error  if (message.includes(&quot;Script error.&quot;)) return false;  // 2. 过滤第三方库错误（如百度统计、广告脚本）  if (    errorData.fileName &amp;&amp;    (errorData.fileName.includes(&quot;baidu.com&quot;) ||      errorData.fileName.includes(&quot;google-analytics.com&quot;))  ) &#123;    return false;  &#125;  // 3. 过滤已知无害错误  const harmlessErrors = [    &quot;ResizeObserver loop limit exceeded&quot;,    &quot;requestIdleCallback is not defined&quot;,  ];  if (harmlessErrors.some((keyword) =&gt; message.includes(keyword))) return false;  // 4. 其他有效错误保留  return true;&#125;\n\n这段代码就是过滤逻辑的“核心过滤器”，靠字符串匹配精准拦下三类无效错误，只让真正有价值的错误进入下一关。\n第二步：去重校验同一错误可能在短时间内反复蹦出来（比如循环里的报错），要是每条都上报，不仅给服务器添负担，还会产生一堆垃圾数据。这一步的核心思路，就是给每个错误贴个“专属身份证”：\n\n根据错误消息、堆栈轨迹这些核心信息，生成一个唯一标识（相当于错误的“身份证号”）。\n\n用一个“缓存容器”记下来已上报的错误和时间戳，还会定期清理 30 秒前的过期缓存，避免占内存。\n\n如果当前错误的“身份证”在缓存里且没过期，说明是重复报错，直接拦下来；反之就放行。\n\n\n123456789101112131415161718192021222324/** * 检查错误是否重复（去重逻辑） * @param errorData 错误数据 * @returns true=重复（拦截），false=不重复（保留） */function isDuplicateError(errorData: Record&lt;string, any&gt;): boolean &#123;  const key = generateErrorKey(errorData);  const cacheItem = errorCache.get(key);  cleanExpiredCache(); // 每次检查都清理过期缓存，避免内存泄漏  return !!(cacheItem &amp;&amp; Date.now() - cacheItem.timestamp &lt; CONFIG.cacheExpire);&#125;/** * 生成错误的唯一标识（基于错误核心信息的哈希） */export function generateErrorKey(errorData: Record&lt;string, any&gt;): string &#123;  // 提取错误核心特征：消息+堆栈（保证同类型错误生成相同key）  const keyStr = `$&#123;errorData.message || &quot;&quot;&#125;-$&#123;errorData.stack || &quot;&quot;&#125;`;  // 简单哈希生成唯一标识（生产环境可替换为md5）  return Array.from(new TextEncoder().encode(keyStr))    .reduce((hash, char) =&gt; (hash &lt;&lt; 5) - hash + char, 0)    .toString();&#125;\n\n这段代码一边给错误绑“身份证”做缓存，一边每次校验时清理过期数据，既解决了重复上报问题，又避免了内存浪费，一举两得。\n第三步：节流控制极端情况下，页面可能短时间内爆一大堆错误（比如接口全挂了），这时候就得给上报“踩脚刹车”，不然服务器可能被冲垮。这一步就像路口的交通管制，有序放行：\n\n默认设置 5 秒的“时间窗口”，窗口内最多上报 10 条错误。\n\n类型错误、网络错误这种关键报错，不受限制直接放行——核心问题可不能漏报。\n\n非关键错误在时间窗口内计数，超过 10 条就拦截并提示，等窗口重置后再恢复上报。\n\n\n123456789101112131415161718192021222324252627282930313233/** * 节流控制：限制单位时间内的上报次数 * @param errorData 错误数据 * @returns true=允许上报，false=拦截 */function checkThrottle(errorData: Record&lt;string, any&gt;): boolean &#123;  const message = errorData.message || &quot;&quot;;  // 关键错误直接放行（不受节流限制）  const isCritical = CONFIG.throttle.criticalErrors.some((keyword) =&gt;    message.includes(keyword)  );  if (isCritical) return true;  // 初始化/重置节流定时器（5秒后重置计数）  if (!throttleTimer) &#123;    throttleTimer = setTimeout(() =&gt; &#123;      throttleCount = 0;      throttleTimer = null;    &#125;, CONFIG.throttle.windowTime);  &#125;  // 超出阈值则拦截并提示  if (throttleCount &gt;= CONFIG.throttle.maxCount) &#123;    console.warn(      `[错误上报节流] 5秒内已上报$&#123;CONFIG.throttle.maxCount&#125;条，本次拦截`,      errorData.message    );    return false;  &#125;  throttleCount++;  return true;&#125;\n\n定时器和计数变量搭配合作，就能实现时间窗口内的流量控制，既不耽误核心问题上报，又能保护服务器不被海量报错冲垮。\n第四步：采样控制要是项目有百万级日活，哪怕经过前面几轮筛选，上报量依然可能很大。采样控制就像“智能闸门”，按比例放行报错，平衡好“问题覆盖”和“服务器压力”：\n\n关键错误依然全额上报，不参与采样。\n\n非关键错误按预设采样率（默认 40%）随机筛选——相当于 100 条错误里挑 40 条上报，既能反映问题分布，又能大幅降低服务器压力。\n\n采样率还能动态调整：高流量时段调低，低峰时段调高，灵活适配不同业务场景。\n\n\n12345678910111213141516/** * 采样控制：按比例上报（高流量场景降低压力） * @param errorData 错误数据 * @returns true=上报，false=拦截 */function checkSample(errorData: Record&lt;string, any&gt;): boolean &#123;  const message = errorData.message || &quot;&quot;;  // 关键错误不受采样限制，全额上报  const isCritical = CONFIG.throttle.criticalErrors.some((keyword) =&gt;    message.includes(keyword)  );  if (isCritical) return true;  // 随机数判断是否命中采样率（0.4即40%概率上报）  const ramdomRate = Math.random();  return ramdomRate &lt;= CONFIG.sampleRate;&#125;\n\n靠随机数和采样率对比实现比例筛选，既不会错过关键问题，又能给服务器“减负”，堪称高流量场景的神器。\n第五步：批量上报经过前面四轮“层层筛选”，剩下的都是“高质量、有价值”的错误。批量上报的思路很简单：不一条一条发，攒够一波再“发车”，减少网络请求次数、提升性能。\n\n用一个队列存通过筛选的错误，同时启动 5 秒定时器。\n\n满足两个条件之一就“发车”：队列满 10 条，或者 5 秒定时器到点——避免队列长期不满导致报错信息延迟。\n\n上报前还会自动补充浏览器版本、系统类型这些信息，给后端多添点线索；发送时优先用更可靠的方式，失败了就自动降级，确保报错信息能成功送达。\n\n\n1234567891011121314151617181920212223242526272829303132333435363738394041/** * 批量上报核心方法 * @param errors 批量错误数据 * @param url 上报接口地址 */function sendBatchErrorData(errors: Record&lt;string, any&gt;[], url: string): void &#123;  if (errors.length === 0) return;  // 合并浏览器信息，补充上下文  const browserInfo = getBrowserInfo();  const dataToSend = errors.map((error) =&gt; (&#123; ...error, ...browserInfo &#125;));  // 优先用sendBeacon，失败降级为fetch（保障页面卸载时也能发送）  if (navigator.sendBeacon) &#123;    const blob = new Blob([JSON.stringify(dataToSend)], &#123;      type: &quot;application/json&quot;,    &#125;);    navigator.sendBeacon(url, blob);  &#125; else &#123;    fetch(url, &#123;      method: &quot;POST&quot;,      headers: &#123; &quot;Content-Type&quot;: &quot;application/json&quot; &#125;,      body: JSON.stringify(dataToSend),      keepalive: true,    &#125;).catch((error) =&gt; console.error(&quot;批量上报失败:&quot;, error));  &#125;&#125;/** * 触发批量上报（清空队列并发送） */function triggerBatchReport(url: string): void &#123;  if (errorBatchQueue.length === 0) return;  const errorsToSend = [...errorBatchQueue];  errorBatchQueue.length = 0;  if (batchTimer) &#123;    clearTimeout(batchTimer);    batchTimer = null;  &#125;  sendBatchErrorData(errorsToSend, url);&#125;\n\n队列存错、定时器触发、双方式降级发送，这套组合拳既减少了网络请求，又保障了上报的可靠性，性价比拉满。\n三、内存泄漏防护错误上报机制中，内存泄漏就是重点防护对象。代码里做了两处“防护措施”，从源头规避问题：\n\n页面卸载前（比如用户关标签页），清理所有定时器、清空错误队列和缓存，不让残留资源占内存。\n\n定期清理过期缓存，防止缓存越积越大，拖慢浏览器速度。\n\n\n1234567891011121314151617181920/** * 清理所有定时器，防止内存泄漏 */function cleanupTimers(): void &#123;  if (throttleTimer) &#123;    clearTimeout(throttleTimer);    throttleTimer = null;  &#125;  if (batchTimer) &#123;    clearTimeout(batchTimer);    batchTimer = null;  &#125;  errorBatchQueue.length = 0;  errorCache.clear();&#125;// 页面卸载前执行清理，避免残留资源if (typeof window !== &quot;undefined&quot;) &#123;  window.addEventListener(&quot;beforeunload&quot;, cleanupTimers);&#125;\n\n靠页面卸载事件绑定清理函数，把定时器、队列、缓存这些资源彻底释放，从根源上杜绝内存泄漏的隐患。\n四、总结：错误上报的核心逻辑总结下来，前端错误上报流程就是一套“层层筛选、按需控制、高效发送”的闭环操作。从筛掉无效错误减少干扰，到去重、节流、采样控制上报量，再到批量发送优化性能，每一步都围绕“精准上报、低耗运行”发力。\n","slug":"一文读懂前端错误上报流程：从拦截到上报的全解析","date":"2025-05-19T16:00:00.000Z","categories_index":"error","tags_index":"前端错误上报,前端监控","author_index":"谢小谢"},{"id":"b3c60852837dddf35463cfd55ac55075","title":"基于HSL色值实现后台管理系统主题色动态切换的原理与实践","content":"一、HSL 色值原理：更适合主题切换的色彩表示法1.1 什么是 HSL 色值HSL 是一种特别贴合人眼色彩感知的色彩空间模型，用三个维度就能精准定义颜色，咱们逐一说说：\n\n色相（Hue）：就是颜色的“本色”，比如红、绿、蓝这些基础色，取值范围是 0°~360°，对应色轮上的不同位置——0° 是红色，120° 是绿色，240° 就是蓝色。\n\n饱和度（Saturation）：控制颜色的鲜艳程度，范围 0%~100%。0%的时候颜色会变成灰蒙蒙的灰度色，100%就是最鲜艳、最纯粹的颜色。\n\n亮度（Lightness）：决定颜色的明暗，同样是 0%~100%。0%是纯黑，50%是颜色本身的亮度，100%就是纯白。\n\n\n和 RGB、十六进制色值比起来，HSL 最大的好处就是直观又好控——不用复杂计算，调整饱和度和亮度，就能轻松做出同一颜色的深浅色阶，这刚好戳中了主题色切换的核心需求。\n1.2 HSL 在主题设计中的核心价值后台系统换主题，可不是只改一个主色就完事了。得同步生成一整套协调的色阶，比如主色的浅 50、浅 100、深 600 等，分别用在按钮、边框、文字、提示框上。而 HSL 的特性，刚好完美适配这种需求：\n\n色阶够统一：固定色相（H），只调亮度（L），就能做出从浅到深的一系列颜色，整套主题的色彩不会乱。\n\n调整够省心：想换主色调，改个色相值就行；想适配亮色、暗色模式，微调饱和度和亮度就搞定，不用重新设计整套色值。\n\n兼容性够稳：所有现代浏览器都支持 HSL 色值，直接通过 CSS 变量注入就行，不用额外做兼容处理。\n\n\n二、基于 HSL 实现主题色切换的核心逻辑（结合代码拆解）给的代码其实就走了三步：生成色阶 → 注入 CSS 变量 → 监听主题更新，靠着 HSL 色值的可扩展性，就实现了后台主题色的动态切换。下面咱们一步步拆解开，慢慢看。\n2.1 核心工具：色阶生成与 HSL 转换主题色切换的基础是有一整套完整的 HSL 色阶，代码里靠generatorColorVariables函数搭配几个工具库实现这个功能。先上核心代码，咱们逐句拆解：\n1234567891011121314151617181920212223242526272829303132333435function generatorColorVariables(colorItems: ColorItem[]) &#123;  const colorVariables: Record&lt;string, string&gt; = &#123;&#125;;  colorItems.forEach((&#123; alias, color, name &#125;) =&gt; &#123;    if (color) &#123;      // 将输入色值标准化为十六进制，避免格式混乱      const colorsMap = getColors(new TinyColor(color).toHexString());      let mainColor = colorsMap[&quot;500&quot;];      const colorKeys = Object.keys(colorsMap);      colorKeys.forEach((key) =&gt; &#123;        const colorValue = colorsMap[key];        if (colorValue) &#123;          // 转换为HSL格式，为CSS变量提供统一输入          const hslColor = convertToHsl(colorValue);          // 生成基础色阶变量（如--primary-500）          colorVariables[`--$&#123;name&#125;-$&#123;key&#125;`] = hslColor;          // 生成别名变量（如--warning-500，关联yellow系列）          if (alias) &#123;            colorVariables[`--$&#123;alias&#125;-$&#123;key&#125;`] = hslColor;          &#125;          // 记录主色（500色阶为核心色值）          if (key === &quot;500&quot;) &#123;            mainColor = hslColor;          &#125;        &#125;      &#125;);      // 为别名设置核心变量（如--warning直接指向--warning-500）      if (alias &amp;&amp; mainColor) &#123;        colorVariables[`--$&#123;alias&#125;`] = mainColor;      &#125;    &#125;  &#125;);  return colorVariables;&#125;\n\n2.1.1 依赖工具\nTinyColor：负责颜色格式转换，比如把各种格式转成十六进制，确保输入的主色值统一，不搞特殊化。\n\ntheme-colors：能根据一个主色自动生成从 50（最浅）到 900（最深）的色阶表，不用自己手动算。\n\nconvertToHsl：自定义小工具，把生成的色值转成 HSL 格式，方便后续统一注入 CSS 变量。\n\n\n2.1.2 色阶生成逻辑拆解（结合代码细品）这个函数的核心，就是把用户配置的几个主色（比如主题色、危险色、成功色），变成一整套能用的 HSL 色阶变量：\n\n接收参数并初始化：函数接收一个colorItems数组，里面存着每个颜色的别名、原始色值和名称，同时建个空对象colorVariables，用来装最终的 CSS 变量。\n\n色值格式统一：通过new TinyColor(color).toHexString()，把不管是 RGB、HSL 还是十六进制的输入色值，都转成十六进制。这一步很关键，能避免输入格式乱七八糟，导致getColors生成色阶出问题——比如用户传rgb(0,122,255)，最终会统一变成#007aff。\n\n自动生成色阶表：getColors会基于标准化后的十六进制色值，自动生成 50 到 900 的 10 个色阶。它底层其实就是靠调整 HSL 的亮度（L），保持色相（H）和饱和度（S）基本不变，比如主色#007aff，会生成 L&#x3D;95%的 50 色阶、L&#x3D;90%的 100 色阶，一直到 L&#x3D;20%的 900 色阶。\n\n转 HSL 并存变量：每个色阶的颜色都会经过convertToHsl转成“色相,饱和度,亮度”的格式，比如217, 100%, 50%，然后分别存成基础变量（比如--primary-500）和别名变量（比如--warning-500）。选 HSL 格式存，是为了后续换主题时，改个色相就能整体切换，不用重新算所有色阶。\n\n关联别名与核心色：咱们约定 500 色阶是核心主色，会把它赋值给mainColor，再给别名生成简化变量——比如--warning直接指向--warning-500。这样用的时候，既可以选具体色阶（--warning-300），也能直接用核心色（--warning），灵活又方便。\n\n\n简单说，这个函数就是把“单一主色”变成“一整套 HSL 色阶”，给后续全局换样式打基础。\n2.2 关键操作：CSS 变量注入与更新色阶生成好后，得把它们注入到页面样式里，靠 CSS 变量实现全局生效。代码里的executeUpdateCSSVariables就是核心，负责批量管理 CSS 变量并注入页面，咱们看代码和逻辑：\n1234567891011121314151617181920212223242526function executeUpdateCSSVariables(  variables: &#123; [key: string]: string &#125;,  id = &quot;__minilo-styles__&quot;): void &#123;  // 单例模式：获取已有样式元素或创建新元素，避免重复注入  const styleElement =    document.querySelector(`#$&#123;id&#125;`) || document.createElement(&quot;style&quot;);  styleElement.id = id;  // 拼接CSS变量字符串，注入:root伪类（全局生效）  let cssText = &quot;:root &#123;&quot;;  for (const key in variables) &#123;    if (Object.prototype.hasOwnProperty.call(variables, key)) &#123;      cssText += `$&#123;key&#125;: $&#123;variables[key]&#125;;`;    &#125;  &#125;  cssText += &quot;&#125;&quot;;  // 写入样式并延迟注入头部，避免阻塞DOM渲染  styleElement.textContent = cssText;  if (!document.querySelector(`#$&#123;id&#125;`)) &#123;    setTimeout(() =&gt; &#123;      document.head.append(styleElement);    &#125;);  &#125;&#125;\n\n2.2.1 实现逻辑\n单例管理样式元素：先查页面里有没有对应 ID 的样式元素，没有就新建一个。这样做是为了避免每次换主题都加新样式元素，导致页面样式又多又乱，始终只留一个全局样式表管理主题变量。\n\n批量拼接 CSS 变量：遍历存着 HSL 色阶的variables对象，拼成:root &#123; --primary-50: 217, 100%, 95%; ... &#125;的格式。:root伪类能让变量全局生效，页面里所有元素都能通过var(--primary-50)引用，这也是 HSL 色值能全局作用于组件的关键。\n\n延迟注入优化性能：用setTimeout延迟把样式元素加到head里，是为了避免样式注入阻塞页面初始渲染，让首屏加载更快。尤其是主题色多、变量量大的时候，这个小优化效果很明显。\n\n\n补充个小知识点：这个函数支持自定义样式元素 ID，默认是__minilo-styles__。如果是多模块项目，不同模块可以用不同 ID，避免变量互相污染。\n2.2.2 变量关联组件样式光有全局 CSS 变量还不够，得和 UI 组件（比如 Element Plus）的内置样式关联起来，主题色才能同步到组件上。useInitGlobalStyle函数就靠 Vue 的响应式监听，实现了这种联动，咱们看代码和逻辑：\n12345678910111213141516171819202122232425262728293031323334353637383940414243export const useInitGlobalStyle = () =&gt; &#123;  const rootStyles = getComputedStyle(document.documentElement);  // 读取原始CSS变量值  const getCssVariableValueRaw = (variable: string) =&gt; &#123;    return rootStyles.getPropertyValue(variable);  &#125;;  // 读取并按需转换为RGB（兼容不支持HSL的组件）  const getCssVariableValue = (    variable: string,    isColor: boolean = true  ): string =&gt; &#123;    const value = getCssVariableValueRaw(variable);    // 若为颜色变量，将HSL转为RGB（部分组件仅支持RGB格式）    return isColor ? convertToRgb(`hsl($&#123;value&#125;)`) : value;  &#125;;  // 监听主题配置变化，实时更新样式  watch(    () =&gt; userConfig.theme,    () =&gt; &#123;      // 读取HSL色阶变量（部分变量直接复用，部分转换为RGB）      const background = getCssVariableValue(&quot;--background&quot;);      const border = getCssVariableValue(&quot;--border&quot;);      const accent = getCssVariableValue(&quot;--accent&quot;);      // 映射Element Plus内置变量与自定义HSL色阶      const variables: Record&lt;string, string&gt; = &#123;        &quot;--el-bg-color&quot;: background,        &quot;--el-border-color&quot;: border,        &quot;--el-border-color-hover&quot;: accent,        &quot;--el-color-primary&quot;: getCssVariableValue(&quot;--primary-500&quot;), // 主色关联--primary-500        &quot;--el-color-danger&quot;: getCssVariableValue(&quot;--destructive-500&quot;), // 危险色关联--destructive-500        // 其他组件变量...      &#125;;      // 注入变量，更新全局样式      executeUpdateCSSVariables(variables, `__myself_design_styles__`);    &#125;,    &#123; immediate: true &#125; // 初始化时立即执行一次，加载默认主题  );&#125;;\n\n关键逻辑说明\n兼容处理很贴心：有些 UI 组件不支持直接用 HSL 变量，所以getCssVariableValue会把存好的 HSL 色值，通过convertToRgb转成 RGB 格式，既保留了 HSL 生成色阶的优势，又解决了兼容性问题。\n\n响应式监听不卡顿：用 Vue 的watch盯着userConfig.theme，只要用户换主题（比如改主色、危险色），就立刻重新读取 HSL 色阶，更新组件内置变量的映射关系，实现实时切换。\n\n初始化避免乱样式：&#123; immediate: true &#125;这个配置很重要，页面加载时会立刻执行一次逻辑，注入默认主题的 HSL 变量，不会出现一开始样式错乱的情况。\n\n\n2.3 闭环控制：主题配置与色值同步代码里靠updateCSSVariables和updateMainColorVariables两个函数，形成了“改配置 → 更色阶 → 更样式”的闭环，确保用户改的主题色能精准同步到全局。咱们看代码和这个闭环怎么跑的：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function updateCSSVariables(config: Config) &#123;  const theme = config?.theme ?? &#123;&#125;;  // 检测核心主题色是否变更（主色、危险色、成功色、警告色）  if (    Reflect.has(theme, &quot;colorPrimary&quot;) ||    Reflect.has(theme, &quot;colorDestructive&quot;) ||    Reflect.has(theme, &quot;colorSuccess&quot;) ||    Reflect.has(theme, &quot;colorWarning&quot;)  ) &#123;    // 变更则重新生成色阶并更新变量    updateMainColorVariables(config);  &#125;&#125;function updateMainColorVariables(config: Config) &#123;  if (!config.theme) return;  const &#123; colorDestructive, colorPrimary, colorSuccess, colorWarning &#125; =    config.theme;  // 生成四大核心色的HSL色阶变量  const colorVariables = generatorColorVariables([    &#123; color: colorPrimary, name: &quot;primary&quot; &#125;, // 主色（primary系列）    &#123; alias: &quot;warning&quot;, color: colorWarning, name: &quot;yellow&quot; &#125;, // 警告色（别名warning，关联yellow系列）    &#123; alias: &quot;success&quot;, color: colorSuccess, name: &quot;green&quot; &#125;, // 成功色（别名success，关联green系列）    &#123; alias: &quot;destructive&quot;, color: colorDestructive, name: &quot;red&quot; &#125;, // 危险色（别名destructive，关联red系列）  ]);  // 核心色变量映射（简化组件引用，如--success指向--green-500）  const colorMappings = &#123;    &quot;--green-500&quot;: &quot;--success&quot;,    &quot;--primary-500&quot;: &quot;--primary&quot;,    &quot;--red-500&quot;: &quot;--destructive&quot;,    &quot;--yellow-500&quot;: &quot;--warning&quot;,  &#125;;  // 同步更新根元素变量，确保全局生效  Object.entries(colorMappings).forEach(([sourceVar, targetVar]) =&gt; &#123;    const colorValue = colorVariables[sourceVar];    if (colorValue) &#123;      document.documentElement.style.setProperty(targetVar, colorValue);    &#125;  &#125;);  // 注入所有HSL色阶变量，更新全局样式  executeUpdateCSSVariables(colorVariables);&#125;\n\n闭环逻辑拆解\n先检测再更新，不做无用功：updateCSSVariables会用Reflect.has检查用户是不是改了四大核心主题色，没改的话就不执行后续操作，避免无效的色阶重生成，提升性能。\n\n重生成色阶并同步变量：如果改了核心色，updateMainColorVariables会调用之前说的generatorColorVariables，重新生成对应色阶，再通过document.documentElement.style.setProperty，把核心变量（比如--success）同步更新，确保简化变量和色阶变量一致。\n\n全局样式一键联动：最后调用executeUpdateCSSVariables注入新的 HSL 色阶变量，因为组件样式早就和这些变量关联好了（比如 Element Plus 的--el-color-success对应--success），所以组件样式会自动跟着变，整个闭环就跑通了。\n\n\n三、HSL 主题切换的优势与扩展场景3.1 核心优势\n色彩够协调：同一色相生成的色阶，换主题后不会出现色彩杂乱的情况，系统视觉风格能保持统一。\n\n性能够能打：靠 CSS 变量批量更样式，不用操作 DOM 元素，切换主题时响应很快，适合复杂的后台系统。\n\n扩展够灵活：支持自定义色阶数量、别名映射，不管是做企业定制主题，还是亮色、暗色模式，都能轻松适配。\n\n\n3.2 扩展场景\n暗色模式快速适配：不用重新定义所有色值，只要把所有 HSL 色阶的亮度（L）整体调低，就能搞定暗色主题。\n\n多主题预设：提前准备好几套色相值，比如蓝色、绿色、紫色，用户切换时只改个色相参数，整套主题就换好了。\n\n自定义调色功能：给用户加个颜色选择器，让他们自己选主色，实时生成 HSL 色阶并更新主题，个性化拉满。\n\n\n四、总结HSL 色值凭着“色相统一、色阶好生成、调整够方便”的特点，妥妥是后台系统主题色切换的最优解之一。咱们今天拆的这套代码，核心就是“把色值转成 HSL 色阶 → 注入 CSS 变量 → 监听配置更新”，一步步实现主题色动态联动。\n这种方案既保证了主题切换的流畅度和色彩协调性，又有很强的扩展性，不管是常规的多主题需求，还是个性化调色，都能满足。对于前端开发来说，算是一套高效又实用的后台主题实现方案了。\n","slug":"基于HSL色值实现后台管理系统主题色动态切换的原理与实践","date":"2025-03-24T16:00:00.000Z","categories_index":"","tags_index":"HSL色值,换肤功能","author_index":"谢小谢"},{"id":"f10979dfbc66a3866a0a2de1362673f9","title":"基于web-vitals封装Vue性能指标上报插件，监控前端体验质量","content":"在前端开发中，性能体验直接影响用户留存——加载慢、交互卡顿、布局跳动，都可能让用户瞬间离开。而 web-vitals 作为 Google 推出的核心 Web 性能指标库，能帮我们精准捕获关键性能数据。今天就结合 Vue3 实战，教大家封装一个可复用的性能指标上报插件，覆盖 SPA 路由切换场景，兼顾灵活性与稳定性。\n一、先搞懂：web-vitals 的核心指标在动手封装前，先明确我们要采集的核心指标，这些指标直接反映用户真实体验：\n\nCLS（累积布局偏移）：衡量页面布局稳定性，值越小越优（建议 ≤0.1），避免元素突然跳动影响阅读。\n\nLCP（最大内容绘制）：衡量页面加载速度，指视口内最大内容元素渲染完成的时间（建议 ≤2.5 秒）。\n\nINP（交互到下一次绘制）：衡量交互响应速度，替代原 FID 指标，反映用户点击、触摸等操作的反馈延迟（建议 ≤200 毫秒）。\n\nFCP（首次内容绘制）：衡量页面首次呈现内容的时间，标志着用户从加载到看到内容的节点（建议 ≤1.8 秒）。\n\nTTFB（首字节时间）：衡量网络请求响应速度，指浏览器接收第一个字节数据的时间（建议 ≤600 毫秒）。\n\n\n这些指标由 web-vitals 库提供现成的采集方法，我们只需基于 Vue 生态封装适配逻辑，再加上上报能力即可。\n二、Vue3 插件封装：从配置到实现我们将封装一个 Vue 插件，支持自定义上报地址、路由联动、去重上报等功能，核心逻辑分为「配置定义 → 工具函数 → 采集逻辑 → 插件挂载」四部分。\n1. 定义类型接口：规范配置与数据结构先通过 TypeScript 定义配置项和上报数据结构，保证类型安全，同时扩展业务所需字段（如项目名称、用户 ID）。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import type &#123; App, Plugin &#125; from &quot;vue&quot;;import type &#123; Router, RouteLocationNormalized &#125; from &quot;vue-router&quot;;import &#123;  onCLS,  onLCP,  onINP,  onFCP,  onTTFB,  type Metric,  type ReportOpts,&#125; from &quot;web-vitals&quot;;/** * 插件配置项（扩展官方能力，适配Vue生态） */export interface WebVitalsPluginOptions &#123;  reportUrl?: string; // 上报接口地址，默认值后续合并  projectName: string; // 多项目区分必备  buildVersion: string; // 版本追溯  router?: Router; // 路由实例，支持SPA切换采集  delay?: number; // 路由切换后延迟采集时间（ms）  metrics?: (&quot;CLS&quot; | &quot;LCP&quot; | &quot;INP&quot; | &quot;FCP&quot; | &quot;TTFB&quot;)[]; // 自定义采集指标  getUserId?: () =&gt; string | null | undefined; // 可选：获取当前用户ID  customReporter?: (data: WebVitalsReportData) =&gt; void; // 可选：自定义上报逻辑  reportFinalOnly?: boolean; // 是否仅上报最终值，避免重复&#125;/** * 上报数据结构（融合官方指标+业务字段） */export interface WebVitalsReportData &#123;  // 官方Metric核心字段（严格对齐，便于后续分析）  name: Metric[&quot;name&quot;];  value: number;  delta: number;  id: Metric[&quot;id&quot;];  startTime: number;  label?: string;  attribution?: any; // 归因数据（需使用attribution版本的web-vitals）  // 业务扩展字段  kind: &quot;performance&quot;;  type: &quot;web-vitals&quot;;  pagePath: string;  pageName: string;  projectName: string;  buildVersion: string;  userId: string | null;  deviceUuid: string; // 设备唯一标识  reportTime: number; // 上报时间戳&#125;\n\n2. 工具函数：解决设备标识、去重与数据构造这部分是插件的基础能力，负责生成设备唯一标识、避免重复上报、构造标准化上报数据，确保采集的准确性。\n（1）设备唯一标识：持久化存储生成设备 UUID 并存在 localStorage 中，用于区分不同设备的性能数据，即使页面刷新也不会丢失。\n123456789101112131415/** * 生成设备唯一标识（持久化到localStorage） */const getDeviceUuid = (): string =&gt; &#123;  const KEY = &quot;web_vitals_device_uuid&quot;;  let uuid = localStorage.getItem(KEY);  if (!uuid) &#123;    // 优先使用浏览器原生API，兼容低版本用时间戳+随机数    uuid = crypto.randomUUID      ? crypto.randomUUID()      : `$&#123;Date.now()&#125;-$&#123;Math.random().toString(36).slice(2, 10)&#125;`;    localStorage.setItem(KEY, uuid);  &#125;  return uuid;&#125;;\n\n（2）去重缓存：避免同一指标重复上报SPA 路由切换后，同一指标可能被重复触发，用 Map 存储“指标 ID-页面路径”，确保同一页面的同一指标仅上报一次。\n12345678910111213141516// 去重缓存：key为指标ID，value为页面路径const reportedMetrics = new Map&lt;string, number&gt;();/** * 路由切换时重置缓存，允许当前页面重新采集 */const resetReportedMetrics = (pagePath: string) =&gt; &#123;  const keysToDelete: string[] = [];  reportedMetrics.forEach((_, key) =&gt; &#123;    if (key.includes(`-$&#123;pagePath&#125;-`)) keysToDelete.push(key);  &#125;);  keysToDelete.forEach((key) =&gt; reportedMetrics.delete(key));  console.log(    `🧹 清除页面 $&#123;pagePath&#125; 的指标缓存，共 $&#123;keysToDelete.length&#125; 条`  );&#125;;\n\n（3）数据构造：融合官方与业务字段将 web-vitals 返回的原始指标，与项目名称、页面路径等业务字段合并，生成标准化上报数据。\n12345678910111213141516171819202122232425262728293031/** * 构造上报数据（严格对齐结构，便于后端解析） */const buildReportData = (  metric: Metric,  pagePath: string,  pageName: string,  options: WebVitalsPluginOptions): WebVitalsReportData =&gt; &#123;  return &#123;    // 官方核心字段    name: metric.name,    value: metric.value,    delta: metric.delta,    id: metric.id,    startTime: (metric as any).startTime,    label: (metric as any).label,    attribution:      &quot;attribution&quot; in metric ? (metric as any).attribution : undefined,    // 业务字段    kind: &quot;performance&quot;,    type: &quot;web-vitals&quot;,    pagePath,    pageName,    projectName: options.projectName,    buildVersion: options.buildVersion,    userId: options.getUserId?.() || null,    deviceUuid: getDeviceUuid(),    reportTime: Date.now(),  &#125;;&#125;;\n\n3. 核心采集逻辑：对接 web-vitals API通过web-vitals 提供的监听方法，按需采集指标，结合配置项控制是否上报最终值、是否捕获历史指标。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * 核心上报逻辑（含去重、错误捕获，不影响主流程） */const reportMetric = (  metric: Metric,  pagePath: string,  pageName: string,  options: WebVitalsPluginOptions): void =&gt; &#123;  // 去重校验：同一页面同一指标ID仅上报一次  const cachedPath = reportedMetrics.get(metric.id);  if (cachedPath === pagePath) return;  reportedMetrics.set(metric.id, pagePath);  // 构建数据，优先使用自定义上报函数，否则用默认函数  const reportData = buildReportData(metric, pagePath, pageName, options);  const reporter =    options.customReporter ||    ((data) =&gt; &#123;      // 假设sendData是通用接口请求函数      sendData(data, options.reportUrl || &quot;/api/v1/monitor/web-vitals&quot;);    &#125;);  // 捕获上报错误，避免阻塞页面逻辑  try &#123;    reporter(reportData);  &#125; catch (err) &#123;    console.warn(`Web Vitals 上报失败 [$&#123;metric.name&#125;]:`, err);  &#125;&#125;;/** * 初始化指标采集（支持路由切换后重新调用） */const initVitalsCollection = (options: WebVitalsPluginOptions): void =&gt; &#123;  const &#123;    metrics = [&quot;CLS&quot;, &quot;LCP&quot;, &quot;INP&quot;, &quot;FCP&quot;, &quot;TTFB&quot;],    reportFinalOnly = true,  &#125; = options;  // 基础配置：buffered=true捕获历史指标，reportAllChanges控制是否上报所有变化  const baseOpts: ReportOpts &amp; &#123; buffered?: boolean &#125; = &#123;    buffered: true,    reportAllChanges: !reportFinalOnly,  &#125;;  // 按需注册指标监听  if (metrics.includes(&quot;CLS&quot;))    onCLS(      (metric) =&gt;        reportMetric(metric, currentPage.path, currentPage.name, options),      baseOpts    );  if (metrics.includes(&quot;LCP&quot;))    onLCP(      (metric) =&gt;        reportMetric(metric, currentPage.path, currentPage.name, options),      baseOpts    );  if (metrics.includes(&quot;INP&quot;))    onINP(      (metric) =&gt;        reportMetric(metric, currentPage.path, currentPage.name, options),      baseOpts    );  if (metrics.includes(&quot;FCP&quot;))    onFCP(      (metric) =&gt;        reportMetric(metric, currentPage.path, currentPage.name, options),      baseOpts    );  if (metrics.includes(&quot;TTFB&quot;))    onTTFB(      (metric) =&gt;        reportMetric(metric, currentPage.path, currentPage.name, options),      baseOpts    );&#125;;\n\n4. 插件封装：适配 Vue3 生态与路由将上述逻辑封装为 Vue 插件，支持首屏采集、路由切换采集、全局方法挂载，完全融入 Vue 项目开发流程。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263export const WebVitalsPlugin: Plugin = &#123;  install(app: App, options: WebVitalsPluginOptions) &#123;    // 合并默认配置    const finalOptions = &#123;      reportUrl: &quot;/api/v1/monitor/web-vitals&quot;,      delay: 100,      reportFinalOnly: true,      ...options,    &#125;;    // 页面上下文：存储当前页面路径和名称，支持路由切换更新    const currentPage = &#123;      path: typeof window !== &quot;undefined&quot; ? window.location.pathname : &quot;&quot;,      name: &quot;FirstLoad&quot;,    &#125;;    // 1. 首屏采集：DOM加载完成后初始化    const initFirstLoad = () =&gt; initVitalsCollection(finalOptions);    if (document.readyState === &quot;complete&quot;) &#123;      initFirstLoad();    &#125; else &#123;      window.addEventListener(&quot;load&quot;, initFirstLoad);    &#125;    // 2. 路由切换采集：更新上下文+重置缓存+重新采集    if (finalOptions.router) &#123;      finalOptions.router.afterEach((to: RouteLocationNormalized) =&gt; &#123;        // 延迟执行，确保DOM更新完成（避免采集到旧页面数据）        setTimeout(() =&gt; &#123;          currentPage.path = to.path;          currentPage.name = (to.name as string) || &quot;UnknownPage&quot;;          resetReportedMetrics(currentPage.path);          initVitalsCollection(finalOptions);        &#125;, finalOptions.delay);      &#125;);    &#125;    // 3. 挂载全局方法：支持组件内手动控制    app.config.globalProperties.$webVitals = &#123;      // 手动更新页面上下文并重新采集      init: (pagePath: string, pageName: string) =&gt; &#123;        currentPage.path = pagePath;        currentPage.name = pageName;        resetReportedMetrics(pagePath);        initVitalsCollection(finalOptions);      &#125;,      // 提示：web-vitals不支持手动销毁监听，仅做提示      dispose: () =&gt; &#123;        console.warn(&quot;Web Vitals 监听无法手动销毁（库限制），仅重置上下文。&quot;);      &#125;,    &#125;;  &#125;,&#125;;// 扩展Vue全局类型，支持TS类型提示declare module &quot;vue&quot; &#123;  interface ComponentCustomProperties &#123;    $webVitals: &#123;      init: (pagePath: string, pageName: string) =&gt; void;      dispose: () =&gt; void;    &#125;;  &#125;&#125;\n\n三、插件使用：快速接入 Vue 项目封装完成后，在 Vue 项目中只需几步即可接入，支持自定义配置满足不同场景需求。\n1. 基础使用（带路由适配）1234567891011121314151617181920212223242526// main.tsimport &#123; createApp &#125; from &quot;vue&quot;;import &#123; createRouter, createWebHistory &#125; from &quot;vue-router&quot;;import App from &quot;./App.vue&quot;;import &#123; WebVitalsPlugin &#125; from &quot;./plugins/web-vitals&quot;;import routes from &quot;./routes&quot;;const router = createRouter(&#123;  history: createWebHistory(),  routes,&#125;);const app = createApp(App);app.use(router);// 接入性能上报插件app.use(WebVitalsPlugin, &#123;  projectName: &quot;vue-web-vitals-demo&quot;,  buildVersion: &quot;v1.0.0&quot;,  router, // 传入路由实例，支持切换采集  metrics: [&quot;CLS&quot;, &quot;LCP&quot;, &quot;INP&quot;], // 只采集核心三个指标  getUserId: () =&gt; localStorage.getItem(&quot;userId&quot;) || null, // 自定义获取用户ID  // 可选：自定义上报逻辑（如对接埋点平台）  // customReporter: (data) =&gt; console.log(&#x27;自定义上报&#x27;, data)&#125;);app.mount(&quot;#app&quot;);\n\n2. 组件内手动控制若某些非路由切换场景（如弹窗内内容加载）需要采集，可通过全局方法手动触发：\n12345678910&lt;script setup lang=&quot;ts&quot;&gt;import &#123; getCurrentInstance &#125; from &quot;vue&quot;;const &#123; proxy &#125; = getCurrentInstance()!;// 手动初始化采集（如弹窗打开后）const handleOpenModal = () =&gt; &#123;  proxy.$webVitals.init(&quot;/modal/detail&quot;, &quot;详情弹窗&quot;);&#125;;&lt;/script&gt;\n\n四、关键注意事项\n归因数据使用：若需要采集指标归因（如 LCP 对应的元素、TTFB 的网络阶段），需安装 web-vitals 的 attribution 版本：npm install web-vitals@attribution。\n\n错误隔离：上报逻辑必须用 try&#x2F;catch 包裹，避免上报失败阻塞页面主流程。\n\n延迟采集时机：路由切换后的 delay 建议设置 100-300ms，确保 DOM 更新完成，采集到当前页面的真实指标。\n\n去重逻辑调整：若需支持同一页面多次采集（如刷新），可修改去重缓存的 key 规则，仅按指标 ID 去重。\n\n\n五、总结通过封装这个 Vue 插件，我们实现了“自动采集+路由适配+灵活配置+错误隔离”的性能指标上报能力，既能精准监控用户体验，又能无缝融入 Vue 项目生态。实际应用中，可根据后端接口需求调整上报数据结构，或对接埋点平台（如百度统计、神策）实现更全面的性能分析。\n性能优化是一个持续迭代的过程，先通过指标采集定位瓶颈，再针对性优化，才能让用户体验不断提升～\n本插件参考代码：minilo 项目\n","slug":"基于web-vitals封装Vue性能指标上报插件，监控前端体验质量","date":"2025-03-10T16:00:00.000Z","categories_index":"","tags_index":"Web-vitals,性能上报","author_index":"谢小谢"},{"id":"c070cc3280800d8c94f2de83786567b7","title":"jenkins环境变量中英文对照表","content":"一、分支与变更相关变量\nBRANCH_NAME：多分支项目中，指当前构建的分支名称。例如可用于仅从主分支部署生产环境，而非功能分支；若对应变更请求（如 PR），该名称通常为随机标识（需参考 CHANGE_ID 和 CHANGE_TARGET）。\nBRANCH_IS_PRIMARY：多分支项目中，若 SCM 源将当前构建分支标记为主分支，则设为“true”，否则未设置。部分 SCM 源可能标记多个主分支，另有部分不提供该信息。\nCHANGE_ID：多分支项目中，若对应变更请求（如 PR），且 SCM 支持，则设为变更 ID（如拉取请求编号），否则未设置。\nCHANGE_URL：多分支项目中，若对应变更请求且 SCM 支持，则设为变更的访问链接，否则未设置。\nCHANGE_TITLE：多分支项目中，若对应变更请求且 SCM 支持，则设为变更的标题，否则未设置。\nCHANGE_AUTHOR：多分支项目中，若对应变更请求且 SCM 支持，则设为变更提议者的用户名，否则未设置。\nCHANGE_AUTHOR_DISPLAY_NAME：多分支项目中，若对应变更请求且 SCM 支持，则设为变更提议者的显示名（中文名&#x2F;全名），否则未设置。\nCHANGE_AUTHOR_EMAIL：多分支项目中，若对应变更请求且 SCM 支持，则设为变更提议者的邮箱地址，否则未设置。\nCHANGE_TARGET：多分支项目中，若对应变更请求且 SCM 支持，则设为变更拟合并的目标分支（基准分支），否则未设置。\nCHANGE_BRANCH：多分支项目中，若对应变更请求，指源代码控制系统中实际的分支名称（可能与 BRANCH_NAME 不同）。例如 GitHub&#x2F;Bitbucket 中，该变量为源分支名，而 BRANCH_NAME 可能是“PR-24”这类格式。\nCHANGE_FORK：多分支项目中，若变更源自分叉仓库且 SCM 支持，则设为分叉仓库名称，否则未设置。\n\n\n二、标签相关变量\nTAG_NAME：多分支项目中，若对应标签构建且 SCM 支持，则设为当前构建的标签名称，否则未设置。\nTAG_TIMESTAMP：多分支项目中，若对应标签构建且 SCM 支持，则设为标签的时间戳（Unix 时间戳，单位毫秒），否则未设置。\nTAG_UNIXTIME：多分支项目中，若对应标签构建且 SCM 支持，则设为标签的时间戳（Unix 时间戳，单位秒），否则未设置。\nTAG_DATE：多分支项目中，若对应标签构建且 SCM 支持，则设为标签的时间戳（格式遵循 java.util.Date#toString()，例如“Wed Jan 1 00:00:00 UTC 2020”），否则未设置。\n\n\n三、构建与任务访问链接变量\nJOB_DISPLAY_URL：指向该任务（Job）的优先用户界面访问链接（跳转链接）。\nRUN_DISPLAY_URL：指向当前构建（Build）的优先用户界面访问链接（跳转链接）。\nRUN_ARTIFACTS_DISPLAY_URL：指向当前构建产物（Artifacts）的优先用户界面访问链接（跳转链接）。\nRUN_CHANGES_DISPLAY_URL：指向当前构建变更日志（Changelog）的优先用户界面访问链接（跳转链接）。\nRUN_TESTS_DISPLAY_URL：指向当前构建测试结果（Test Results）的优先用户界面访问链接（跳转链接）。\n\n\n四、核心构建环境变量\nCI：固定设为字符串“true”，标识当前为“持续集成”执行环境。\nBUILD_NUMBER：当前构建编号，例如“153”。\nBUILD_ID：当前构建 ID。Jenkins 1.597+版本中与 BUILD_NUMBER 一致，旧版本中为“YYYY-MM-DD_hh-mm-ss”格式的时间戳。\nBUILD_DISPLAY_NAME：当前构建的显示名称，默认格式如“#153”。\nJOB_NAME：当前构建的项目名称，例如“foo”或“foo&#x2F;bar”（含文件夹路径）。\nJOB_BASE_NAME：当前构建的项目简称（去除文件夹路径），例如“bar&#x2F;foo”的简称为“foo”。\nBUILD_TAG：格式为“jenkins-${JOB_NAME}-${BUILD_NUMBER}”的字符串。JOB_NAME 中的所有正斜杠（“&#x2F;”）会替换为短横线（“-”），适用于写入资源文件、Jar 包等，方便标识构建版本。\nEXECUTOR_NUMBER：执行当前构建的 executor 唯一编号（同一节点内）。该编号与“构建执行器状态”中显示的编号一致，但从 0 开始（而非 1）。\nNODE_NAME：构建所在代理节点（Agent）的名称；若在内置节点运行（Jenkins 2.306 前为“master”），则为“built-in”。\nNODE_LABELS：构建所在节点的标签列表（以空格分隔）。\nWORKSPACE：分配给当前构建的工作空间绝对路径。\nWORKSPACE_TMP：工作空间附近的临时目录，不可浏览且不干扰 SCM 检出。初始可能不存在，需按需创建（如 Linux 中执行“mkdir -p”）。当工作空间为磁盘根目录时，该变量未定义。\nJENKINS_HOME：Jenkins 控制器文件系统中，用于存储数据的绝对路径。\nJENKINS_URL：Jenkins 的完整访问地址，例如“http://server:port/jenkins/”（需在系统配置中设置 Jenkins URL 才会生效）。\nBUILD_URL：当前构建的完整访问地址，例如“http://server:port/jenkins/job/foo/15/”（需设置 Jenkins URL）。\nJOB_URL：当前任务的完整访问地址，例如“http://server:port/jenkins/job/foo/”（需设置 Jenkins URL）。\n\n\n五、Git 相关变量\nGIT_COMMIT：当前检出的提交哈希值。\nGIT_PREVIOUS_COMMIT：当前分支上一次构建的提交哈希值（若存在）。\nGIT_PREVIOUS_SUCCESSFUL_COMMIT：当前分支上一次成功构建的提交哈希值（若存在）。\nGIT_BRANCH：远程分支名称（若存在）。\nGIT_LOCAL_BRANCH：当前检出的本地分支名称（若适用）。\nGIT_CHECKOUT_DIR：代码仓库的检出目录。若设置了“检出到子目录”，则该变量为对应子目录路径。\nGIT_URL：远程仓库的 URL。若存在多个远程仓库，则依次为 GIT_URL_1、GIT_URL_2 等。\nGIT_COMMITTER_NAME：当前工作空间后续提交将使用的 Git 提交者名称（若配置）。该值读取自 Jenkins“系统配置”中的“全局配置 user.name 值”。\nGIT_AUTHOR_NAME：当前工作空间后续提交将使用的 Git 作者名称（若配置）。该值读取自 Jenkins“系统配置”中的“全局配置 user.name 值”。\nGIT_COMMITTER_EMAIL：当前工作空间后续提交将使用的 Git 提交者邮箱（若配置）。该值读取自 Jenkins“系统配置”中的“全局配置 user.email 值”。\nGIT_AUTHOR_EMAIL：当前工作空间后续提交将使用的 Git 作者邮箱（若配置）。该值读取自 Jenkins“系统配置”中的“全局配置 user.email 值”。\n\njenkins role\n凭据（Credentials）\nCreate：创建新凭据，支持账号密码、密钥等类型。\nDelete：移除无需使用的已有凭据。\nManageDomains：管理凭据域，实现凭据的分组分类管理。\nUpdate：修改现有凭据的内容或配置信息。\n\n\n任务（Job）\nView：查看任务的基本信息及构建状态。\nBuild：手动触发任务的构建流程。\nCancel：终止正在执行的任务构建。\nConfigure：修改任务的构建步骤、触发器等配置。\nCreate：在 Jenkins 中新建各类任务（如自由风格、流水线任务）。\nDelete：删除无用的任务。\nDiscover：查看文件夹内包含的所有任务。\nMove：将任务移动到其他文件夹。\nRead：读取任务的基础配置信息。\nWorkspace：访问任务构建对应的工作目录。\n\n\n运行（Run）\nDelete：删除任务的历史构建记录。\nReplay：复用历史构建的参数和脚本，重新执行构建。\n\n\n视图（View）\nUpdate：更新视图的显示内容或属性。\nConfigure：配置视图包含的任务、展示样式等。\nCreate：新建自定义视图，实现任务的分组展示。\nDelete：删除不需要的视图…\n\n\n\n","slug":"jenkins环境变量中英文对照表","date":"2025-02-24T16:00:00.000Z","categories_index":"Jenkins","tags_index":"Jenkins,自动化构建","author_index":"谢小谢"},{"id":"6454991adcd7885c39f198934a9d7391","title":"Vite中Pinia多实例问题及解决方案","content":"一、问题概述在 Vite 构建的项目中，若 Pinia 被多次打包，会创建多个独立的 Pinia 模块实例，导致 Store 定义与使用时引用不同实例，最终出现 Store 获取失败（如 _s 为 undefined）的问题。\n二、多实例问题产生的原因核心原因Pinia 被重复打包生成多个独立实例，Store 的定义与挂载分别依赖不同实例，导致实例间无法互通。\n具体场景假设项目采用 Monorepo 结构（或多包依赖结构），存在如下目录组织：\n123├── apps/web → 主应用，依赖 pinia（生成实例 A）└── packages/store → 独立Store包，也依赖 pinia（生成实例 B）\n\n构建后出现实例冲突：\n\npackages/store 中通过 defineStore 定义 Store 时，使用的是 Pinia 实例 B\n\napps/web 中通过 app.use(pinia) 挂载到应用的，是 Pinia 实例 A\n\n\n当调用 useUserStore() 时，代码会尝试从挂载的实例 A 中获取 Store，但该 Store 实际注册在实例 B 中，导致获取失败。\n三、为什么 _s 是 undefinedPinia 内部简化逻辑Pinia 获取 Store 的核心逻辑如下，可直观说明问题根源：\n12345678910// Pinia 内部简化逻辑function useStore(id) &#123;  const pinia = inject(piniaSymbol); // 获取当前应用挂载的 Pinia 实例  // pinia._s 是存储所有 Store 的 Map 对象  if (!pinia._s.has(id)) &#123;    // 若不存在则创建 Store（此处省略创建逻辑）  &#125;  return pinia._s.get(id);&#125;\n\n问题本质\n实例 A（应用挂载的实例）的 pinia._s 为空，因为 Store 未注册到该实例上；\n\n实例 B（Store 定义依赖的实例）虽注册了 Store，但未被应用挂载，无法被获取；\n\n两个实例的 piniaSymbol 互不相同，导致 inject(piniaSymbol) 要么返回错误实例，要么返回 undefined，最终pinia._s 无法正常访问。\n\n\n四、dedupe 解决方案配置方式在 Vite 配置中通过 resolve.dedupe 强制指定包的单一副本，解决多实例问题：\n123456// vite.config.jsexport default &#123;  resolve: &#123;    dedupe: [&quot;vue&quot;, &quot;pinia&quot;, &quot;vue-router&quot;], // 强制共用这些包的同一个副本  &#125;,&#125;;\n\n解决原理该配置告诉 Vite&#x2F;Rollup：无论这些包被项目中哪个模块导入，都强制使用同一个副本。效果如下：\n\npackages/store 中 import &#123; defineStore &#125; from &#39;pinia&#39; → 引用实例 A\n\napps/web 中 import &#123; createPinia &#125; from &#39;pinia&#39; → 引用同一个实例 A\n\n\n所有代码统一依赖同一个 Pinia 模块，Store 的定义与获取都基于同一个实例，pinia._s 能正确找到已注册的 Store，问题得以解决。\n","slug":"Vite中Pinia多实例问题及解决方案","date":"2025-02-09T16:00:00.000Z","categories_index":"Vue3","tags_index":"Pinia,错误定位","author_index":"谢小谢"},{"id":"de3462e688a74cbb7ce1f99f46dd5a64","title":"说一说web性能指标","content":"想打造让人眼前一亮的高性能前端应用？那这些指标就像应用的“健康体检表”，既能帮我们精准拿捏性能短板，又能针对性优化，让用户体验直接拉满。今天我们就从加载和交互两大维度，把这些关键指标逐个拆解，带你吃透前端性能优化的核心密码～\n加载相关FCP：首次内容绘制FCP 全称为 First Contentful Paint，即首次内容绘制，表示页面绘制其第一个非白色元素（如文本、图像、非空白 canvas 或 SVG）所需的时间。\n在下图中，FCP 发生在第二张图时：\n\n这个指标直接关系到用户的体验，如果 FCP 时间过长，用户将会面对长时间的空白页面，进而可能误以为网站故障，甚至选择离开并寻找其他选项。虽然 FCP 并不涵盖整个页面的加载时间，但它却反映了用户开始与页面进行视觉交互的速度。在 Chrome DevTools 的 Lighthouse 面板中可以测量 FCP 得分：\n\n理想的 FCP 时间应控制在 1.8 秒之内：\n\n可以考虑通过以下方式来优化 FCP 时间：\n\n降低服务器响应时间：确保服务器能迅速响应请求，这样浏览器就能更快地开始处理并渲染页面内容。可以通过优化服务端代码、改善静态资源的提供方式（如将图片部署到 CDN）来实现。\n延迟加载非关键资源：对于非关键的脚本和 CSS 样式表，使用defer属性或async属性（对于脚本）来延迟加载，这样它们就不会阻塞页面的初次渲染。\n移除不必要的资源：检查页面并移除那些未被使用的样式表和 JavaScript 脚本，这些不必要的资源会拖慢 FCP 的时间。\n内联关键样式：虽然这种做法会受到质疑，但如内联一些关键的 CSS 样式确实可以减少浏览器解析外部资源所需的时间，从而加快渲染速度。\n\nLCP：最大内容绘制LCP 全称为 Largest Contentful Paint，即最大内容绘制，用于记录视窗内最大的元素绘制的时间，这个时间会随着页面渲染变化而变化，因为页面中的最大元素在渲染过程中可能会发生改变，该指标会在用户第一次交互后停止记录。\n在下图中，LCP 发生在第三张图时：\n\n根据规范，LCP 考虑的元素类型包括：\n\n&lt;img&gt; 元素。\n&lt;svg&gt; 元素内嵌的 &lt;image&gt; 元素。\n&lt;video&gt; 元素。\n使用 url() 函数加载背景图片的元素。\n包含文本节点或其他内嵌文本元素子元素的块级元素。\n\n在 Chrome DevTools 的 Lighthouse 面板中可以测量 LCP 得分：\n\n理想的 LCP 时间应控制在 2.5 秒之内：\n\nTTFB：首字节时间TTFB，全称为 Time to First Byte，即首字节时间，表示从点击网页到接收到第一个字节的时间。\n在下图中，TTFB 测量的是 startTime 和 responseStart 之间的时间总和：\n这个时间段包括：\n\n重定向时间\nService Worker 启动时间\nDNS 查找\n连接和 TLS 协商\n请求，直到响应的第一个字节到达\n\n理想的 TTFB 时间应控制在 800 毫秒之内：\n\nTBT：总阻塞时间TBT 全称为 Total Blocking Time，即总阻塞时间，用于衡量的是长任务对主线程的阻塞时间总和。即从首次内容绘制（FCP）到页面达到可交互时间（TTI）期间，主线程因运行长任务而被阻塞的总时间，因此，TBT 会对首次输入延迟\n有很大影响。长任务是指那些执行时间超过 50 毫秒的 JavaScript 任务，因为它们可能会阻塞页面的渲染和响应，从而影响用户体验。\n在 Chrome DevTools 的 Lighthouse 面板中可以测量 TBT 得分：\n\n减少 TBT 时间的方式包括：\n\n减轻第三方代码的影响\n缩短 JavaScript 执行时间\n减少主线程的工作量\n控制请求数量和传输大小\n\n理想情况下，TBT 在移动设备上应低于 300 毫秒，在桌面 Web 上应低于 100 毫秒。\nFMP：首次有效渲染FMP 全称为 First Meaningful Paint，即首次有效渲染。它衡量的是从用户开始加载页面到浏览器首次渲染出对用户来说有意义的内容（如文本、图片、按钮等可交互元素）所花费的时间。\nFMP 的计算比较复杂，因为它涉及到“有意义”内容的定义。在实际应用中，通常需要根据具体的应用场景和用户需求来确定哪些内容被认为是“有意义”的。\n\nFP：首次绘制FP 全称为 First Paint，即首次绘制，表示浏览器首次将像素渲染到屏幕上的时间点。在性能统计指标中，从用户开始访问 Web 页面的时间点到 FP 的时间点这段时间可以被视为白屏时间，即用户看到的都是没有任何内容的白色屏幕。FP 指标反映了页面的白屏时间，白屏时间的长短直接影响了用户的体验和满意度。\n首次绘制与其他性能指标如 First Contentful Paint (FCP) 和 Largest Contentful Paint (LCP) 相关但有所不同：\n\nFCP（首次内容绘制）：指的是页面首次绘制文本或图像的时间点，通常在 FP 之后发生，因为它涉及到更具体的页面内容。\nLCP（最大内容绘制）：指的是页面上最大的文本块或图像元素完成绘制的时间点，它关注的是页面主要内容的可见性。\n\n\nSI：速度指数SI 全称为 Speed Index，即速度指数，用于衡量页面渲染用户可见内容迅速程度。Speed Index 并不是一个具体的时间点，而是一个综合性指标。它表示页面从加载开始到页面内容基本可见的过程中，用户感受到的加载速度。该指标是基于视频捕获的可视进度或从绘制事件的可视进展来计算。\n\n一般来说，在移动设备上，Speed Index 低于 3.4s，在桌面上低于 1.3s 时，Lighthouse 才能获得 90 以上的评分。\n交互相关CLS：累积布局偏移CLS 全称为 Cumulative Layout Shift，即累积布局偏移，用于衡量一个页面在加载过程中，由于内容的加载和渲染，导致页面布局发生多次变化的情况。具体来说，CLS 指标衡量的是页面中可见元素在加载过程中由于内容加载而发生的位置偏移。这些元素可能因为图片、广告、视频等资源的加载而发生移动。如果一个页面的元素在加载过程中频繁移动，那么这个页面的 CLS 值就会比较高，这通常不是一个好的用户体验。\n\n\n\n\n\n\n\n\n\n注意：只有意外的布局变化才会计入 CLS 分数。如果内容在用户交互（例如点击）后移动，则不会增加 CLS。\n在 Chrome DevTools 的 Lighthouse 面板中可以测量 CLS 得分：\n\nCLS 的值范围通常是从 0 到 1，其中 0 表示没有布局偏移，1 表示布局偏移非常严重。一个较低的 CLS 值意味着页面在加载过程中布局稳定，用户可以更流畅地浏览页面。理想的 CLS 时间应控制在 0.1 之内：\n\nCLS 分数是通过将影响分数与距离分数相乘来计算的，其中：\n\n影响分数：视口中会移动的不稳定元素的总面积占比。如果页面加载过程中有覆盖视口 60% 面积的元素移动了，那么影响分数就是 0.6。\n距离分数：视口中任何单一元素移动的最大距离与视口高度的比值。假设一个元素从位置（0, 100）移动到（0, 500），这导致了 400px 的垂直偏移。如果视口的高度是 1000px，那么距离分数就是 400px &#x2F; 1000px &#x3D; 0.4。\n\n则累积布局偏移分数是 0.6 x 0.4 &#x3D; 0.375。\n影响 CLS 分数的常见的原因主要有：\n\n图片、视频和 iframe 没有预先设定尺寸，导致页面加载时元素位置变化。\n字体加载过程中可能产生文本短暂消失或样式未加载的文本闪烁，影响布局稳定性。\n动态内容（如广告、通知等）注入 DOM 后，尤其是网络请求之后，往往会导致页面布局发生突变。\n\nCLS 是由于布局中的意外变化而发生的，因此在编写 HTML 和 CSS 时，可以考虑以下原则：\n\n避免布局重叠：不要将新元素插入到现有元素之上，因为这可能导致页面布局发生意外的变化。尤其是当插入通知或警告框时，应该考虑使用不会干扰其他页面元素的设计方法。\n预留空间：为图像和视频元素指定尺寸属性，以便浏览器在内容加载之前就能为它们预留出正确的空间。这有助于防止页面在加载过程中发生不必要的布局调整。\n谨慎使用动画：动画和过渡效果可以提升用户体验，但应确保它们不会导致页面布局发生不必要的改变。选择那些不会移动元素或改变布局尺寸的过渡效果，以保持页面的稳定性和一致性。\n\nINP：交互到下一次绘制INP 全称为 Interaction to Next Paint，即交互到下一次绘制，用来衡量用户与网页交互后，浏览器完成下一次屏幕绘制所需的时间。这个指标主要关注的是用户交互（如点击、触摸、键盘输入等）之后，页面响应并渲染新内容的速度。\nINP 会测量以下延迟：\n\n输入延迟：用户交互和浏览器能够处理事件之间的时间，类似于 FID。\n处理延迟：浏览器处理事件处理程序所需的时间\n显示延迟：浏览器重新计算布局并将像素绘制到屏幕上所需的时间。\n\n\n理想的 INP 时间应控制在 200 毫秒之内：\n\n对于 INP，只观测以下互动类型：\n\n使用鼠标点击。\n点按带有触摸屏的设备。\n实体键盘或屏幕键盘键。\n\nFID：首次输入延迟FID 全称为 First Input Delay，即首次输入延迟，是衡量网页性能的一个重要指标，它反映了用户在页面加载过程中首次与页面交互时的体验。FID 特别关注用户首次点击按钮、链接、输入字段等可交互元素时，页面响应这些交互所需的时间。\nFID 仅测量输入延迟，即用户输入和浏览器开始执行事件处理程序之间的时间。\n\nINP 是 FID 的继任指标。虽然两者都是响应能力指标，但 FID 仅测量了页面上首次互动的输入延迟，而 INP 则通过考虑所有页面互动（从输入延迟到运行事件处理程序所需的时间，再到浏览器绘制下一帧）来改进 FID。这使得 INP 成为更可靠的整体响应能力指标。\nTTI：可交互时间TTI 全称为 Time To Interactive，即可交互时间，用于评估页面从开始加载到用户可以顺畅地与之交互的时间点。TTI 特别关注页面的响应性和交互性，它试图捕捉用户能够开始与页面进行流畅交互的瞬间。\nTTI 时间主要取决于以下因素：\n\n页面布局稳定，所有可见的内容都已经被加载。\n主线程空闲。如果还在加载脚本或处理其他任务，那么应用将不会处于交互状态。用户的点击和其他操作将被忽略（或排队）直到线程空闲。\n\n可以通过减少脚本的加载时间来降低 TTI 时间，因为脚本的加载和处理往往是造成高 TTI 的元凶。以下是一些优化策略：\n\n清除冗余脚本：移除所有未使用的脚本，避免浏览器花费时间去解析不必要的代码，从而提升页面加载速度。\n分割脚本文件：将大型脚本拆分成多个较小的文件。这有助于浏览器更有效地加载和解析这些脚本，减少阻塞时间。\n动态加载脚本：对于来自外部资源且无法直接分割或修改的脚本，考虑采用动态加载的方式，以减少对页面初始加载时间的影响。\n\nCore Web VitalsCore Web Vitals 是一组由 Google 推出的关键用户体验指标，旨在帮助开发人员评估和优化网站的性能。这些指标主要关注三个方面：加载性能、交互性能和视觉稳定性。\nCore Web Vitals 包含了三个指标：\n\nINP（Interaction to Next Paint）：用于评估页面交互的性能，它衡量的是从用户与页面进行交互（如点击、触摸等）到页面下一次绘制（Paint）之间的时间。\nLCP（Largest Contentful Paint）：用于评估页面加载的性能，它衡量的是页面加载的最大内容元素（如文本块或图片）出现在屏幕上的时间。\nCLS（Cumulative Layout Shift）：用于评估页面视觉稳定性，它衡量的是页面在加载过程中由于内容布局变化而发生的意外移动。\n\n\n性能测量工具可以借助 Gooogle 开源的 web-vitals\n库来测量一些性能指标：\n12345678import &#123; onCLS, onINP, onLCP, onFCP, onFID, onTTFB &#125; from &quot;web-vitals&quot;;onCLS(console.log);onINP(console.log);onLCP(console.log);onFCP(console.log);onFID(console.log);onTTFB(console.log);\n\n使用 Google 提供免费的 PageSpeed Insights\n(PSI) 工具来测试网站的性能：\n\n使用 Chrome Devtools 的 Lighthouse 选项卡测试性能指标：\n\n注意，在 Lighthouse 中，不同指标在总分数中的占比是不同的：\n\n","slug":"web性能指标介绍","date":"2024-12-31T16:00:00.000Z","categories_index":"","tags_index":"性能优化,web性能指标","author_index":"谢小谢"},{"id":"a5e1de8bcca72c1338dc7ea35c5a612c","title":"openapi搭配swagger实现自动化axios和TS结构生成","content":"前言自从 vue3 版本推出之后，typescript 就进入了众多 vue 选手的视野，但是使用 axios 来请求时，往往会出现返回的结构体需要专门定义，且旧的 axios 还需要根据新项目来花大量时间来定义和改造 typescript 返回结构体，这让我们团队的同事头疼不已，我做为团队组长，有必要解决这个问题。\n解决问题的方案：Hey APIHey API 是 OpenAPI 到 TypeScript 的 codegen，我们团队使用的 swagger 文档遵循的就是 openapi 规范，Hey API 和 swagger 文档相结合可以使用 axios 配置和返回结构体的自动生成，下面我使用公司的后台管理系统来演示下改造方案\n依赖安装1pnpm add @hey-api/client-axios &amp;&amp; pnpm add @hey-api/openapi-ts -D\n\n策略 1：axios 实例配置自动生成12345678910111213141516171819202122232425// 1.项目根目录增加配置文件import &#123; defineConfig &#125; from &quot;@hey-api/openapi-ts&quot;;export default defineConfig(&#123;  client: &quot;@hey-api/client-axios&quot;, // 所使用类型包  input: &quot;http://127.0.0.1:3000/api-json&quot;, // swagger文档地址  output: &#123;    format: &quot;prettier&quot;, // 格式化策略    lint: &quot;eslint&quot;,    path: &quot;./src/client&quot;, // 输出地址  &#125;,  types: &#123;    dates: &quot;types+transform&quot;,    enums: &quot;javascript&quot;,  &#125;,&#125;);// 2.package.json配置&quot;scripts&quot;: &#123;    &quot;openapi-ts&quot;: &quot;openapi-ts&quot;&#125;// 3.命令执行pnpm run openapi-ts\n\n文件生成执行步骤 3 后会生成 client 文件夹\n\nservice.gen.ts 里面包含了所有生成的接口文档方法, 下面是里面自动生成的范例\n12345678910111213/** * 获取所有员工 */export function findAllEmployee&lt;ThrowOnError extends boolean = false&gt;(options?: Options&lt;unknown, ThrowOnError&gt;) &#123;  return (options?.client ?? client).get&lt;    FindAllEmployeeResponse,    FindAllEmployeeError,    ThrowOnError  &gt;(&#123;    ...options,    url: &#x27;/findAllEmployee&#x27;,  &#125;)&#125;\n\n增加 axios 拦截器创建 config.ts，引入配置文件，初始化拦截器\n\naxios 拦截器方法调用生效\n这些步骤下来，通过自动生成的结构体和 axios 方法，此后将不再需要自己写 axios 的配置方法和返回的结构体，大大提高团队开发小绿绿\n参考链接：Hey API 官网\n","slug":"openapi搭配swagger实现自动化axios","date":"2024-09-19T16:00:00.000Z","categories_index":"经验","tags_index":"axios,openapi","author_index":"谢小谢"},{"id":"0839313cbc7ea1f3e84fdd64f99688d0","title":"Vue-Office预览工具","content":"Vue-Office：高效简洁的 pdf 预览工具在 B 端管理类系统中，企业经常面临大量文档附件的预览需求，例如合同、方案、报告等。一个好用的在线文档预览解决方案，能够大幅提升系统的用户体验和文档管理效率。这篇文章将为大家介绍一款基于 Vue 的文档预览工具——vue-office。\nvue-office 专注于文档预览功能，支持多种常见格式，如 PDF 和 Word，基于成熟的底层库构建，提供稳定可靠的预览体验。\n\n1. 什么是 vue-office？vue-office 是一个 Vue 组件库，旨在解决文档预览在 Web 应用中的集成难题。通过它，开发者可以轻松在管理系统中添加文档在线预览功能，避免用户频繁下载文件，提高工作效率。\n核心功能特点\n多格式支持： 支持 .pdf、.docx 等主流办公文档格式的预览。\n基于成熟库： PDF 预览基于 pdf.js，Word 预览基于 docx-preview，提供稳定和高质量的渲染效果。\n轻量化集成： 提供 Vue 组件，开箱即用，配置简单。\n性能优化： 针对大文件的加载和预览进行了性能优化，确保流畅的用户体验。\n\n\n2. vue-office 的功能亮点2.1 支持多种文档格式的预览\nPDF 文件预览：\n基于 Mozilla 的 pdf.js 库，渲染效果接近原生。\n支持分页浏览、缩放、跳转页面等操作。\n\n\nWord 文档预览：\n使用 docx-preview 进行渲染，支持常见的 .docx 文件格式。\n渲染效果稳定，兼容性好，适合合同和报告等场景的文档预览。\n\n\n其它格式扩展：\n可以通过插件或额外配置支持 Excel、图片、文本等其它附件的预览。\n\n\n\n2.2 易于集成与自定义\n提供简单的 Vue 组件接口，几行代码即可实现文档预览功能。\n支持自定义样式和交互逻辑，满足不同业务需求。\n\n\n3. 如何快速集成 vue-office以下是集成预览和使用 vue-office 的快速指南：\n\n3.1 安装 vue-office使用 npm 或 yarn 安装：\n12345bash复制代码npm install vue-office --save\n\n或者：\n123yarn add vue-office\n\n3.2 使用示例以下是一个实现 PDF 和 Word 文件预览的示例：\nPDF 文件预览123456789101112131415161718192021&lt;template&gt;  &lt;div class=&quot;pdf-viewer&quot;&gt;    &lt;VueOfficePdf :file=&quot;pdfFile&quot; /&gt;  &lt;/div&gt;&lt;/templat&lt;script&gt;import VueOfficePdf from &#x27;vue-office/pdf&#x27;;export default &#123;  components: &#123; VueOfficePdf &#125;,  data() &#123;    return &#123;      pdfFile: &#x27;https://example.com/document.pdf&#x27; // PDF 文件 URL    &#125;;  &#125;&#125;;&lt;/script&gt;\n\nWord 文件预览1234567891011121314151617181920&lt;template&gt;  &lt;div class=&quot;word-viewer&quot;&gt;    &lt;VueOfficeWord :file=&quot;wordFile&quot; /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import VueOfficeWord from &#x27;vue-office/word&#x27;;export default &#123;  components: &#123; VueOfficeWord &#125;,  data() &#123;    return &#123;      wordFile: &#x27;https://example.com/document.docx&#x27; // Word 文件 URL    &#125;;  &#125;&#125;;&lt;/script&gt;\n\n\n3.3 支持的 Props 和事件\n\n\nProp\n类型\n说明\n\n\n\nfile\n`File\nString`\n\n\nloading\nBoolean\n是否显示加载动画，默认值为 true。\n\n\noptions\nObject\n配置预览行为，例如缩放模式、页面布局等。\n\n\n\n4. 实际应用场景4.1 B 端管理类系统的大量附件预览需求在许多 B 端系统中，比如企业管理后台、OA 办公系统或在线审批平台，文档附件预览是一个高频需求。通过 vue-office，可以快速实现以下功能：\n\n在无需下载的情况下直接预览文档，提高用户体验。\n支持 PDF 和 Word 文档的高质量渲染，满足企业对合同、审批报告等文件的展示需求。\n提供轻量化的组件，降低开发成本，减少不必要的复杂度。\n\n4.2 法务系统中的合同文档管理在法务系统中，合同的在线预览和校对是常见需求。vue-office 提供流畅的 PDF 和 Word 预览体验，帮助法务人员快速定位合同内容，提高审核效率。\n\n5. vue-office 的对比优势\n\n\n特性\nvue-office\n自己集成 pdf.js 和 docx-preview\n\n\n\n开发成本\n开箱即用，简单易集成\n需要自己封装，开发周期较长\n\n\n功能扩展性\n提供统一接口，灵活扩展\n难以统一管理，扩展需要额外开发\n\n\n兼容性\n集成了优化方案，兼容稳定\n底层库原生问题需自行处理\n\n\n通过 vue-office，开发者可以免去复杂的底层封装工作，专注于业务功能的开发。\n\n6. 总结vue-office 是一款专注于文档预览功能的 Vue 组件库，基于成熟的 pdf.js 和 docx-preview 库，提供高质量的 PDF 和 Word 渲染效果。在 B 端管理类系统中，它可以帮助开发者快速实现附件预览功能，提升产品的用户体验。\n亮点总结：\n\n支持 PDF 和 Word 文档的高质量预览，渲染稳定。\n集成简单，开箱即用，适合快速开发场景。\n性能优化良好，适用于大文件和多文档的预览需求。\n\n如果你正在开发一个需要附件预览的管理系统，不妨试试 vue-office，让你的系统功能更上一层楼！\n","slug":"Vue-Office介绍","date":"2024-06-07T16:00:00.000Z","categories_index":"介绍","tags_index":"Vue-office,Vue插件","author_index":"谢小谢"},{"id":"7a8ea0bc07f9bbaa57fab7575f0fd41d","title":"SSE技术和websocket","content":"前言随着 chatgpt3，4 版本的推出，AI 应用的崛起态势已非常明显，当我看到 AI 应用回答我提问的时候，我非常好奇 AI 应用是如何做到不卡的，毕竟有那么多文字，如果一个一个轮询的话效率会非常慢，需要频繁请求。于是我搜了搜相关技术，发现了 SSE 这个服务器主动推送的东西，这不免让我想到了 Websocket。那这两者有什么区别呢？\nSSE 流式传输如标题所言，通过 SSE 流式传输的方式可以让我们不再通过轮询的方式获取服务端返回的结果，进而提升前端页面的性能。\n对于需要轮询的业务场景来说，采用 SSE 确实是一个更好的技术方案。接下来，我将 SSE 的概念、与 Websocket 对比、SSE 应用场景多个方面介绍 SSE 流式传输\n什么是 SSE 流式传输SSE 全称为  Server-sent events , 是一种基于 HTTP 协议的通信技术，允许服务器主动向客户端（通常是 Web 浏览器）发送更新。\n它是 HTML5 标准的一部分，设计初衷是用来建立一个单向的服务器到客户端连接，使得服务器可以实时地向客户端发送数据。\n这种服务端实时向客户端发送数据的传输方式，其实就是流式传输。\n因为我经常使用字节跳动的 AI 应用“豆包”的原因，可以发现豆包的响应总是间断完成。细扒豆包的网络传输模式，可以发现，用的也是流式传输。\n\nSSE 流式传输的好处在  SSE  技术出现之前，我们习惯把需要等待服务端返回的过程称为长轮询。\n长轮询的实现其实也是借助 http 请求来完成，一个完整的长轮询过程如下图所示：\n\n从图中可以发现，长轮询最大的弊端是当服务端响应请求之前，客户端发送的所有请求都不会被受理。并且服务端发送响应的前提是客户端发起请求。\n前后端通信过程中，我们常采用 ajax 、axios 来异步获取结果，这个过程，其实也是长轮询的过程。\n而同为采用 http 协议通信方式的 SSE 流式传输，相比于长轮询模式来说，优势在于可以在不需要客户端介入的情况下，多次向客户端发送响应，直至客户端关闭连接。\n这对于需要服务端实时推送内容至客户端的场景可方便太多了！\nSSE 技术原理1. 参数设置前文说到，SSE 本质是一个基于 http 协议的通信技术。\n因此想要使用  SSE  技术构建需要服务器实时推送信息到客户端的连接，只需要将传统的  http 响应头的 contentType 设置为 text&#x2F;event-stream 。\n并且为了保证客户端展示的是最新数据，需要将  Cache-Control 设置为 no-cache 。\n在此基础上，SSE  本质是一个 TCP 连接，因此为了保证 SSE 的持续开启，需要将  Connection 设置为 keep-alive 。\n1234Content-Type: text/event-streamCache-Control: no-cacheConnection: keep-alive\n\n完成了上述响应头的设置后，我们可以编写一个基于  SSE  流式传输的简单 Demo 。\n2. SSE Demo服务端代码：\n123456789101112131415161718192021222324252627282930313233const express = require(&quot;express&quot;);const app = express();const PORT = 3000;app.use(express.static(&quot;public&quot;));app.get(&quot;/events&quot;, function (req, res) &#123;  res.setHeader(&quot;Content-Type&quot;, &quot;text/event-stream&quot;);  res.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);  res.setHeader(&quot;Connection&quot;, &quot;keep-alive&quot;);  let startTime = Date.now();  const sendEvent = () =&gt; &#123;    // 检查是否已经发送了10秒    if (Date.now() - startTime &gt;= 10000) &#123;      res.write(&quot;event: close\\ndata: &#123;&#125;\\n\\n&quot;); // 发送一个特殊事件通知客户端关闭      res.end(); // 关闭连接      return;    &#125;    const data = &#123; message: &quot;Hello World&quot;, timestamp: new Date() &#125;;    res.write(`data: $&#123;JSON.stringify(data)&#125;\\n\\n`); // 每隔2秒发送一次消息    setTimeout(sendEvent, 2000);  &#125;;  sendEvent();&#125;);app.listen(PORT, () =&gt; &#123;  console.log(`Server running on http://localhost:$&#123;PORT&#125;`);&#125;);\n\n客户端代码：\n1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;SSE Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;Server-Sent Events Example&lt;/h1&gt;    &lt;div id=&quot;messages&quot;&gt;&lt;/div&gt;    &lt;script&gt;        const evtSource = new EventSource(&#x27;/events&#x27;);        const messages = document.getElementById(&#x27;messages&#x27;);        evtSource.onmessage = function(event) &#123;            const newElement = document.createElement(&quot;p&quot;);            const eventObject = JSON.parse(event.data);            newElement.textContent = &quot;Message: &quot; + eventObject.message + &quot; at &quot; + eventObject.timestamp;            messages.appendChild(newElement);        &#125;;    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n当我们在浏览器中访问运行在 localhost: 3000 端口的客户端页面时，页面将会以  流式模式  逐步渲染服务端返回的结果\n需要注意的是，为了保证使用  SSE  通信协议传输的数据能被客户端正确的接收，服务端和客户端在发送数据和接收数据应该遵循以下规范：\n服务端基本响应格式SSE  响应主要由一系列以两个换行符分隔的事件组成。每个事件可以包含以下字段：\n12345data：事件的数据。如果数据跨越多行，每行都应该以data:开始。id：事件的唯一标识符。客户端可以使用这个ID来恢复事件流。event：自定义事件类型。客户端可以根据不同的事件类型来执行不同的操作。retry：建议的重新连接时间（毫秒）。如果连接中断，客户端将等待这段时间后尝试重新连接。\n\n字段之间用单个换行符分隔，而事件之间用两个换行符分隔。\n客户端处理格式客户端使用  EventSource  接口监听  SSE  消息：\n12345const evtSource = new EventSource(&#x27;path/to/sse&#x27;);evtSource.onmessage = function(event) &#123;    console.log(event.data); // 处理收到的数据&#125;;\n\nSSE 应用场景SSE  作为基于  http  协议由服务端向客户端单向推送消息的通信技术，对于需要服务端主动推送消息的场景来说，是非常适合的\n\nAI 对话\n实时天气\n实时股票\n\nSSE 兼容性\n可以发现，目前市面上绝大多数浏览器都支持  SSE  通信。\nSSE 与 WebSocket 对比 h看完 SSE 的使用方式后，细心的同学应该发现了：\nSSE  的通信方式和  WebSocket  很像啊，而且 WebSocket 还支持双向通信，为什么不直接使用 WebSocket ？\n对于这三者的详细区别，你可以参考下面我总结的表格：\n以下是 WebSocket、轮询和 SSE 的对比表格：\n\n\n\n特性\nWebSocket\n轮询 Polling\nServer-Sent Events (SSE)\n\n\n\n定义\n全双工通信协议，支持服务器和客户端之间的双向通信。\n客户端定期向服务器发送请求以检查更新。\n服务器向客户端推送数据的单向通信协议。\n\n\n实时性\n高，服务器可以主动推送数据。\n低，依赖客户端定时请求。\n高，服务器可以主动推送数据。\n\n\n开销\n相对较高，需要建立和维护持久连接。\n较低，但频繁请求可能导致高网络和服务器开销。\n相对较低，只需要一个 HTTP 连接，服务器推送数据。\n\n\n浏览器支持\n现代浏览器支持，需要额外的库来支持旧浏览器。\n所有浏览器支持。\n现代浏览器支持良好，旧浏览器可能需要 polyfill。\n\n\n实现复杂性\n高，需要处理连接的建立、维护和关闭。\n低，只需定期发送请求。\n中等，只需要处理服务器推送的数据。\n\n\n数据格式\n支持二进制和文本数据。\n通常为 JSON 或 XML。\n仅支持文本数据，通常为 JSON。\n\n\n控制流\n客户端和服务器都可以控制消息发送。\n客户端控制请求发送频率。\n服务器完全控制数据推送。\n\n\n安全性\n需要 wss:&#x2F;&#x2F;（WebSocket Secure）来保证安全。\n需要https:&#x2F;&#x2F;来保证请求的安全。\n需要 SSE 通过 HTTPS 提供，以保证数据传输的安全。\n\n\n适用场景\n需要双向交互的应用，如聊天室、实时游戏。\n适用于更新频率不高的场景，如轮询邮箱。\n适用于服务器到客户端的单向数据流，如股票价格更新。\n\n\n跨域限制\n默认不支持跨域，需要服务器配置 CORS。\n默认不支持跨域，需要服务器配置 CORS。\n默认不支持跨域，需要服务器配置 CORS。\n\n\n重连机制\n客户端可以实现自动重连逻辑。\n需要客户端实现重连逻辑。\n客户端可以监听连接关闭并尝试重连。\n\n\n服务器资源\n较高，因为需要维护持久连接。\n较低，但频繁的请求可能增加服务器负担。\n较低，只需要维护一个 HTTP 连接。\n\n\n这个表格概括了 WebSocket、轮询和 SSE 在不同特性上的主要对比点。每种技术都有其适用的场景和限制，选择合适的技术需要根据具体的应用需求来决定。可以发现，SSE  与  WebSocket  各有优缺点，对于需要客户端与服务端高频交互的场景，WebSocket 确实更适合；但对于只需要服务端单向数据传输的场景，SSE 确实能耗更低，且不需要客户端感知。\n","slug":"SSE和websocket","date":"2024-04-13T16:00:00.000Z","categories_index":"总结","tags_index":"http,AI","author_index":"谢小谢"},{"id":"fc0084e39f16c44f947668a585ecf5c2","title":"旧版本Vuex如何做持久化","content":"怎么实现vuex的持久化缓存Vuex持久化缓存通常指的是将Vuex中的state状态保存到本地存储中，这样即使在页面刷新或关闭后，重新打开页面仍然可以恢复之前的状态。实现Vuex持久化缓存有几种不同的方法，以下是一些常见的实现方式：\n使用localStorage或sessionStorage我们可以手动将Vuex的state序列化后保存到localStorage或sessionStorage中，并在应用启动时从存储中恢复状态。\n12345678910111213141516171819202122232425262728293031// 保存state到localStoragefunction saveToStorage(state) &#123;  localStorage.setItem(&#x27;vuex-state&#x27;, JSON.stringify(state));&#125;​// 从localStorage恢复statefunction loadFromStorage() &#123;  const storedState = localStorage.getItem(&#x27;vuex-state&#x27;);  return storedState ? JSON.parse(storedState) : &#123;&#125;;&#125;​// 在Vuex的mutations中使用const mutations = &#123;  saveState(state) &#123;    saveToStorage(state);  &#125;&#125;;​// 在Vuex的actions中恢复stateconst actions = &#123;  restoreState(&#123; commit &#125;) &#123;    const savedState = loadFromStorage();    if (Object.keys(savedState).length) &#123;      commit(&#x27;hydrateState&#x27;, savedState);    &#125;  &#125;&#125;;​// 在组件中或在应用启动时调用恢复state的actiondispatch(&#x27;restoreState&#x27;);\n\n快速使用：vuex-persist插件npm install vuex-persist，然后，在我们的Vuex store中使用这个插件：\n12345678910111213141516171819javascript复制代码import Vue from &#x27;vue&#x27;;import Vuex from &#x27;vuex&#x27;;import vuexPersist from &#x27;vuex-persist&#x27;;​Vue.use(Vuex);​const store = new Vuex.Store(&#123;  // ...我们的state, mutations, actions等&#125;);​const vuexPersist = new vuexPersist(&#123;  key: &#x27;vuex&#x27;, // 存储的名称  storage: window.localStorage, // 存储方式，可以选择sessionStorage或localStorage  // 其他配置...&#125;);​// 使用插件vuexPersist.plugin(store);\n\n注意\n\n序列化: 当我们将state保存到本地存储时，确保state中的数据可以被序列化。这意味着state中不应该包含函数、undefined等不能被JSON序列化的数据。\n安全性: 存储在localStorage或sessionStorage中的数据可以被同源的任何JavaScript代码访问，因此不要存储敏感信息。性能: 避免频繁地读写本地存储，因为这可能会影响性能。\n\nvuex-persist 插件扩展vuex-persist是一个第三方Vuex插件，它提供了一种简便的方式来持久化Vuex的状态。这个插件的实现基于几个关键步骤：\n\n序列化状态: 插件首先会将Vuex store的状态（state）序列化成JSON字符串。这是通过JSON.stringify()实现的，确保状态对象中所有的数据都是可以被序列化的。\n存储状态: 序列化后的状态字符串被保存到浏览器的localStorage或sessionStorage中。vuex-persist允许我们通过配置来选择使用哪一种存储方式。监听状态变化: 插件会监听Vuex store的状态变化。每当状态发生变化时，插件都会自动将新的状态序列化并更新到本地存储中。这通常是通过订阅Vuex store的mutation事件来实现的。\n恢复状态: 当应用启动或者需要从持久化存储中恢复状态时，插件会从localStorage或sessionStorage中读取状态字符串，并使用JSON.parse()将其解析回原始的对象结构。\n自动恢复: vuex-persist通常在Vuex store初始化时自动执行状态恢复的逻辑。这意味着在我们的应用启动时，如果本地存储中有保存的状态，vuex-persist会自动恢复这些状态。\n配置选项: vuex-persist提供了多种配置选项，允许我们定制化持久化的行为。例如，我们可以配置要持久化的state片段（通过paths选项），或者设置一个函数来在保存之前过滤状态（通过reducer选项）。\n版本控制: 插件还可以处理版本控制问题，如果我们的应用升级后state结构发生了变化，vuex-persist可以通过配置（如reducer函数）来确保向后兼容。\n集成Vuex严格模式: 当Vuex store配置为严格模式时，vuex-persist能够确保所有状态的变更都是通过mutations进行的，即使这些变更是由插件自身触发的。\n\n","slug":"Vuex本地持久化","date":"2024-02-10T16:00:00.000Z","categories_index":"","tags_index":"Vue,Vuex","author_index":"谢小谢"},{"id":"be8b20988d64ed90b36f55c5730a76e9","title":"记一次uni-app原生应用高德地图配置的坑","content":"前言为配合打荷生鲜 2.0 小程序的发展，需要对配送人员增加一个类似于美团骑手版的安卓 App，为此需要引入高德地图的 sdk，折腾了我一天的时候，为此将遇到的问题记录下来\n新开项目如何引用 uni-app 原生插件？\n创建新项目，记录下 appId\n将新项目与第三方插件绑定\n项目配置再次进行绑定\n\n至此，插件的初步使用已经完成\n如何结合高德地图 sdk？\n登录 DCloud 开发者中心，我的应用，应用信息-&gt;各平台信息，记下包名&#x2F;appid，应用信息-&gt;Android 云端证书-&gt;证书详情，记下证书的别名， SHA1 码，密码，并把证书下载到本地\n前往高德地图控制台-&gt;应用管理-&gt;我的应用-&gt;创建应用，配置应用的 packageName 和 SHA1 码一定要和 Dcloud 的证书一致，不一致的话，基座打包后调用 api 会报 ERROR_CODE:7 错误\n创建应用配置完，回到列表拿到应用的 key，回填到 uni-app 项目配置中\n基座打包，填写包名，证书别名，密码，上传证书，开始进行打包\n真机调试，打开 Hbuilder&#x2F;Hbuilderx-&gt;运行-&gt;运行到手机或模拟器-&gt;运行到 Android App 基座-&gt; 使用自定义基座运行\n\n总结主要的坑点还是在 packageName 包名那块，官方也没说明怎么生成 SHA1 码，于是就自己用 keytool 自己生成了，结果显而易见，一直卡在那边，通过慢慢结合网上摸索才得出解决办法。\n","slug":"记一次uni-app原生应用高德地图配置的坑","date":"2023-11-15T16:00:00.000Z","categories_index":"经验","tags_index":"原生小程序,高德地图","author_index":"谢小谢"},{"id":"717767a9d0fa35b0ddd204ab9b9e0cde","title":"厨易科技低代码平台搭建思考","content":"由于公司之前的项目用的有赞的 saas，每年的费用高达几十万，对于小公司来说是一笔不小的支出所以另行组建了团队。我 5 月份进来作为前端这块的组长，在主导小程序的时候，另外一个比较重要的任务是需要从 0 到 1 主导管理低代码物料平台，以支持运营同事小程序前端的自定义编辑操作，后期可能还要兼容到 H5\n技术选型目前市面上不管是 Vue 或者 React 已经有了较为成熟的方案，搭配公司主要技术栈，还是以 Vue3 全家桶搭配 vite&#x2F;webpack 这一套为主\n低代码平台的操作方式\n\n\n市面方案\n优缺点\n难易度\n\n\n\n代码驱动+json 段\n比较适合开发人员作为主要操作者\n有一定难度，特别对于不会代码的同学\n\n\n拖拽驱动+自定义配置\n适合对技术一窍不通的小白\n基本无难度\n\n\n基于公司运营同学本身特点优先还是选用了拖拽驱动+自定义配置\n基础 demo 图 如下\n可以预见的难点\nPC 端尺寸单位为 px，小程序前台为 rpx，是否需要做兼容？\nPC 端组件的组件为原生，小程序是自己封装的一套，如何进行适配？\n如果有商品组件的话，或者更多需要网络请求的，如何动态化保存当前组件中商品信息，在前端如何自定义请求？\n组件中可能会存在很多用户态的校验，事件绑定逻辑的情况，这一块要如何处理？\n预览和草稿功能的实现\n\n问题 1通常不需要做兼容，因为公司 UI 的宽度都是以 375 的屏幕宽度来定义设计图，在前台设编辑器窗口计预览的时候，把宽度也定义成 375 既可\n问题 2由于公司小程序是原生的，并不具备像 uni-app 或 taro 这种条件编译的情况，所以两边没办法用同一套的方案，除非后面基本技术栈转成 taro 或 uni-app。那目前的办法就只能在 PC 维护一套，然后自行通过小程序语法做人工的同步功能适配。\n问题 3商品组件中如果有网络请求的情况下，目前想到的解决方法有 2 个：第一是前端通过数据模型对象数组项里面的某一个 key 值，判断某一个 key 来做 http 请求处理，这样的性能好，但是体验差。第二是把当前选择商品放在后端，后端查询后集体返回，这样的话体验好，但是网络请求的时间可能会稍长，经过深思熟虑后还是选用了前者\n问题 4事件绑定的情况下，数据模型单独拎出一个 key，循环所有的 key 挂载在小程序 this 对象里面，小程序端和 PC 端同步命名，这样可以解决事件绑定问题。对于用户态，只需要在小程序事件绑定方法内增加一个用户态拦截指令即可\n问题 5预览和保存功能由于是在 H5 端，所以处理方式都是通过数据模型来做映射，好的一点是可以和 PC 那边一样共用组件，减少开发二次开发的难度\n总结此 下一篇。\n","slug":"厨易科技低代码平台搭建思考","date":"2023-06-30T16:00:00.000Z","categories_index":"低代码","tags_index":"原生小程序,物料系统","author_index":"谢小谢"},{"id":"e9f45a92e7df43e08b58c2d1279189cb","title":"Vue3自定义图片懒加载指令","content":"之前用习惯了别人的图片懒加载指令，现在自己也试着写了一个，在这里记录下自己过程中的心得体会，当前指令逻辑使用于 vue2 和 vue3\n图片懒加载原理使用 html 自定义数据先覆盖图片或者背景图的默认地址，从少图片资源加载，当滚动条拉动到可视区的时候才逐渐加载图片，从而提高网站性能 ## 目标 实现图片懒加载和背景图片的懒加载，并且支持自定义默认图片\n开始 需要明白的两点\n需要设置一个自定义默认图片的自定义属性\n需要传入一个值设置当前是图片的懒加载还是背景图片的懒加载，背景图片需要从一开始就设定好宽度，才能计算 下面开始代码\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import &#123; App, DirectiveBinding &#125; from &quot;vue&quot;;/** ** @Description: 设置样式 ** @Author: shuhongxie ** @param &#123;any&#125; arg 传入的类型 ** @param &#123;HTMLElement&#125; el DOM元素 ** @param &#123;string&#125; value 图片url值 **/function setStyle(arg: any, el: HTMLElement, value: string) &#123;  !arg    ? el.setAttribute(&quot;src&quot;, value)    : (el.style.backgroundImage = `url(\\&quot;$&#123;value&#125;\\&quot;)`);&#125;/** * * @Description: 初始化图片懒加载 * * @Author: shuhongxie * * @param &#123;HTMLElement&#125; el DOM元素 * * @param &#123;DirectiveBinding&#125; binding **/function initLazy(el: HTMLElement, binding: DirectiveBinding) &#123;  // 默认图片  const beforeHandImage =    el.getAttribute(&quot;lazy-init-img&quot;) || &quot;http://www.ay1.cc/img?w=300&amp;h=300&quot;;  // 屏幕高度   const contentHeight = document.body.clientHeight  // 不使用offsetTop是因为如果父级有定位的话 那么offsetTop是相对于父级而不是浏览器窗口  let elOffsetTop =    el.getBoundingClientRect().top + document.documentElement.scrollTop;  // 图片高度大于当前屏幕就替换调原始图片  if (elOffsetTop &gt; contentHeight) &#123;    // 没有就直接赋值当前图片    setStyle(binding.arg, el, beforeHandImage);  &#125; else &#123;    setStyle(binding.arg, el, binding.value);  &#125;  window.addEventListener(&quot;scroll&quot;, () =&gt; &#123;    const scrollTop =      document.documentElement.scrollTop ||      window.pageYOffset ||      document.body.scrollTop; // 刷新完重新定义高度    elOffsetTop =      el.getBoundingClientRect().top + document.documentElement.scrollTop; // 到达可视区就设置样式    if (scrollTop + contentHeight &gt; elOffsetTop) &#123;      setStyle(binding.arg, el, binding.value);    &#125;  &#125;);&#125;export default (app: App) =&gt; &#123;  // v-lazy 图片懒加载指令 beforeHandImage 初始化的图片  app.directive(&quot;lazy&quot;, &#123;    mounted(el, binding, vnode, oldVnode) &#123;      setTimeout(() =&gt; &#123;        initLazy(el, binding);      &#125;, 0);    &#125;,    updated(el, binding) &#123;      setTimeout(() =&gt; &#123;        initLazy(el, binding);      &#125;, 0);    &#125;,    unmounted() &#123;      window.removeEventListener(&quot;scroll&quot;, null);    &#125;,  &#125;);&#125;;\n\n可以看到，上图通过定义个一个 lazy-init-img 的自定义属性和传入了一个 background 指令参数来切换成背景图模式，不传则是图片模式，通过使用 getBoundingClientRect 方法获取到浏览器的距离，在所有队列任务执行完之后重新计算高度，执行对应的逻辑\n","slug":"Vue3自定义图片懒加载指令","date":"2023-02-24T16:00:00.000Z","categories_index":"vue3,经验","tags_index":"Vue3","author_index":"谢小谢"},{"id":"0f52401eaa7baffae19fe63567938437","title":"uni-app微信小程序实现axios请求拦截器和重复请求中断","content":"最近在写二手表微信小程序的时候，发现老是会有重复请求的情况，用了函数防抖和布尔拦截之后，又显得非常臃肿，没能从根本上解决问题，刚好 leader 叫我做一下重复请求拦截。可是，当我翻开 flyio 文档之后……\nWhat the fuck没想到 flyio 竟然没有预设重复请求功能，绝望\n\n当前目标和处理思路那么我的目标就变成了兼容旧 flyio 的拦截器功能，并且还要实现重复请求拦截功能。对接重复请求拦截，因为我们当前小程序只有微信端，那我就直接换成了微信小程序官方的请求，刚好也有请求中断功能。对于拦截器，基本都是通过 promise 来实现的，那这里就直接自己写一个。\n请求和响应拦截的思路通过 Promise.then 实现链式的串行调用，因为前置有请求拦截器，后置有响应拦截器，中间插入请求结构体。整体结构如下图\n\n代码细究整体工具库使用 lodash\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142export const callFor = (arrayData, fn) =&gt; &#123;  arrayData.forEach(item =&gt; &#123;    fn.call(null, item)  &#125;)&#125;// 全局拦截器实例export default class Interceptor &#123;  constructor() &#123;    this.handlers = []  &#125;  // use方法传入Promise两个状态处理语句  use(fulfilled, rejected) &#123;    this.handlers.push(&#123;      fulfilled,      rejected    &#125;)    return this.handlers.length - 1  &#125;&#125;// 主体请求参数 作为promise调用链的入参之一const requestFn = config =&gt; &#123;  const options = config  // requestTaskKey 当前重复请求的url标识  let lastRequestKey = config.hasOwnProperty(&#x27;requestTaskKey&#x27;) ? config.requestTaskKey : &#x27;&#x27;  // 如果全局变量数组里面含有当前的请求，那么就直接中断上一次请求  if (    lastRequestKey &amp;&amp;    getApp().hasOwnProperty(&#x27;requestTasks&#x27;) &amp;&amp;    getApp().requestTasks.hasOwnProperty(lastRequestKey)  ) &#123;    try &#123;      console.log(&#x27;中断了上一次的请求----------------------&#x27;)      getApp().requestTasks[lastRequestKey].abort()      // 中断后就应该清除掉      delete getApp().requestTasks[lastRequestKey]    &#125; catch (e) &#123;      console.error(e)    &#125;  &#125;  // 返回一个promise  return new Promise((resolve, reject) =&gt; &#123;    const url = options.baseURL + options.url    options.url = url    const requestTask = uni.request(&#123;      ...options,      complete: res =&gt; &#123;        console.log(res)        // 每一次成功之后 就清空当前url在全局变量数组里面的位置        // request:faile abort为公司自定义的错误请求状态，        if (res.errMsg !== &#x27;request:faile abort&#x27; &amp;&amp; lastRequestKey) &#123;          delete getApp().requestTasks[lastRequestKey]        &#125;        if (res.errMsg === &#x27;request:ok&#x27;) &#123;          return resolve(&#123; ...res, request: options &#125;)        &#125; else if (res.errMsg === &#x27;request:fail&#x27;) &#123;          return reject(&#123; ...res, request: options &#125;)        &#125;      &#125;    &#125;)    // 如果当前请求需要支持重复请求的中断，    if (lastRequestKey) &#123;      // 没有队列的情况下 全局变量存储队列      if (!getApp().requestTasks) &#123;        getApp().requestTasks = &#123;&#125;      &#125;      // 把当前请求塞入存储队列之中      getApp().requestTasks[lastRequestKey] = requestTask    &#125;  &#125;)&#125;function HttpRequest(config) &#123;  // 深拷贝配置防止配置被上一个请求修改  this.config = _.cloneDeep(    Object.assign(      &#123;&#125;,      &#123;        baseURL: &#x27;&#x27;,        url: &#x27;&#x27;,        data: &#123;&#125;,        header: &#123;&#125;,        method: &#x27;GET&#x27;,        timeout: 60000      &#125;,      config    )  )  // 初始化拦截器  this.interceptors = &#123;    request: new Interceptor(),    response: new Interceptor()  &#125;&#125;HttpRequest.prototype.request = function (config = &#123;&#125;) &#123;  const options = Object.assign(&#123;&#125;, this.config, config)  console.log(options)  let requestInterceptorChain = [],    responseInterceptorChain = []  // 推入请求拦截器  this.interceptors.request.forEach(obj =&gt; &#123;    requestInterceptorChain.unshift(obj.fulfilled, obj.rejected)  &#125;)  // 推入响应拦截器  this.interceptors.response.forEach(obj =&gt; &#123;    responseInterceptorChain.push(obj.fulfilled, obj.rejected)  &#125;)  let promise  // 第二个值为undefined是因为要为后面的请求进行补位 这样可以防止流入错误请求  let chain = [requestFn, undefined]  // request请求拦截插入最前方  Array.prototype.unshift.call(chain, ...requestInterceptorChain)  // responese响应插入最后方  chain = chain.concat(responseInterceptorChain)  promise = Promise.resolve(options)  // promise.then串行处理  while (chain.length) &#123;    promise = promise.then(chain.shift(), chain.shift())  &#125;  return promise&#125;// 不同请求格式的差异化处理callFor([&#x27;post&#x27;, &#x27;put&#x27;, &#x27;patch&#x27;], function (methodType) &#123;  HttpRequest.prototype[methodType] = function (url, data = &#123;&#125;, otherConfig = &#123;&#125;) &#123;    const config = Object.assign(&#123;&#125;, &#123; data, url, method: methodType &#125;, otherConfig)    return this.request(config)  &#125;&#125;)callFor([&#x27;delete&#x27;, &#x27;get&#x27;, &#x27;head&#x27;, &#x27;config&#x27;], function (methodType) &#123;  HttpRequest.prototype[methodType] = function (url, params = &#123;&#125;, otherConfig = &#123;&#125;) &#123;    const config = Object.assign(&#123;&#125;, otherConfig, &#123; url, params, method: methodType &#125;)    return this.request(config)  &#125;&#125;)export default HttpRequest\n\n这就是我基于 Prmiose 加小程序重复请求封装的核心代码，这里还未涉及到离开页面时的请求中断行为。不过大概思路的话就是收集所有请求的状态，封装成对象，调用时修改状态，后续有时间我会更加深究这部分的代码，更好地服务于业务。\n","slug":"uni-app微信小程序实现axios请求拦截器和重复请求中断","date":"2022-12-07T16:00:00.000Z","categories_index":"axios,微信小程序","tags_index":"uni-app,http,微信小程序","author_index":"谢小谢"},{"id":"8940855b891d4b3c9c870535631ad9ab","title":"StoryBook-为万表组件库提供文档说明","content":"前言对于公司级组件库来说，服务于业务的组件存在着参数较多，参数经常记不住问题。而且，脆弱的在线调试也为组件使用产生了很大的不便，好在出现了 StoryBook 这个神器，弥补了这个不足之处。\n为 Vue 使用 storybook，基于 Vue-cli 环境搭建\n\n\n\n\n\n\n\n\n集成 storybook 依赖\n1npx storybook init\n\n执行之后会在根目录生成storybook项目文件，如下图\n\n\n\n\n\n\n\n\n\n\n为你的组件库组件&#x2F;方法&#x2F;指令提供全局注册，继承 Vue 实例行为，修改.storybook&#x2F;preview.js\n12345678910111213141516export const parameters = &#123;  actions: &#123; argTypesRegex: &quot;^on[A-Z].*&quot; &#125;,  controls: &#123;    matchers: &#123;      color: /(background|color)$/i,      date: /Date$/,    &#125;,  &#125;,&#125;;import &#123; app &#125; from &quot;@storybook/vue3&quot;;// app相当于main.js文件中引入的Vue实例// Vue3示例操作，增加全局方法/变量app.config.globalProperties.OSS = config.OSS[&quot;production&quot;];app.config.globalProperties.OSS_STATIC = config.OSS.static;app.config.globalProperties.ERROR_IMG = config.PIC.errorPage;\n\n配置主入口，为 storybook 自有文件提供解析\n123456789101112131415161718192021222324const path = require(&quot;path&quot;);module.exports = &#123;  // glob模式匹配文件  stories: [&quot;../src/package/*/*.(js|jsx|ts|tsx)&quot;],  // 相关库支持  addons: [    &quot;@storybook/addon-links&quot;,    &quot;@storybook/addon-essentials&quot;,    &quot;@storybook/addon-interactions&quot;,    &quot;@storybook/preset-scss&quot;, // scss语法支持  ],  // 自定义webpack配置，相当于vue.config.js里面的configureWebpack选项  webpackFinal: async (config, &#123; configType &#125;) =&gt; &#123;    config.resolve.alias[&quot;@&quot;] = path.resolve(__dirname, &quot;../src&quot;);    config.resolve.alias[&quot;@wb-ui&quot;] = path.resolve(__dirname, &quot;../src&quot;);    return config;  &#125;,  // 依赖的主包  framework: &quot;@storybook/vue3&quot;,  core: &#123;    builder: &quot;@storybook/builder-webpack5&quot;,  &#125;,&#125;;\n\n\n\n\n\n\n\n\n\n\n修改文件模板行为，配置你的组件样式，居中显示\n细心的你在预览的时候可能会看到下面的情况，预览始终不居中\n\n增加 preview-body.html\n1234567&lt;style&gt;  #root &#123;    display: flex;    justify-content: center;    align-items: center;  &#125;&lt;/style&gt;\n\n\n\n\n\n\n\n\n\n\n为业务组件增加 iconfont 支持\n万表相关组件是使用的阿里字体图标，在.storybook 文件夹下增加 preview-head.html\n1&lt;link rel=&quot;stylesheet&quot; href=&quot;//at.alicdn.com/t/link.css&quot; /&gt;\n\n\n\n\n\n\n\n\n\n\n为组件编写组件描述文件\n官方文档参考：https://storybook.js.org/docs/vue/writing-stories/introduction\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 引入组件import WbList from &quot;./index&quot;;import &#123; Meta, StoryFn &#125; from &quot;@storybook/vue3&quot;;export default &#123;  // 组件名称  title: &quot;wb-list&quot;,  // 组件实例  component: WbList,  // 编辑props描述  argTypes: &#123;    status: &#123;      description:        &quot;状态常量 NO_MORE: 没有更多/LOAD：加载中/END：到底/ERROR：错误&quot;,      required: true,    &#125;,    total: &#123;      description: &quot;数据总体长度&quot;,    &#125;,    enableFlex: &#123;      description: &quot;是否开启flex布局&quot;,    &#125;,    emptyText: &#123;      description: &quot;数据为空时的文本&quot;,    &#125;,    emptyStyle: &#123;      description: &quot;数据为空时的文本样式&quot;,    &#125;,    emptyImageStyle: &#123;      description: &quot;数据为空时的图片样式&quot;,    &#125;,  &#125;,&#125; as Meta&lt;typeof WbList&gt;;// 配置显示模板const Template: StoryFn&lt;typeof WbList&gt; = (args) =&gt; (&#123;  components: &#123; WbList &#125;,  setup() &#123;    return &#123; args &#125;;  &#125;,  template: `&lt;wb-list v-bind=&quot;args&quot; :status=&quot;status&quot; :total=&quot;0&quot; enable-flex &gt;    &lt;div style=&quot;width:200px;height:200px;background: red;margin-right:10px;&quot; v-for=&quot;item in [1, 2, 3, 4]&quot; :key=&quot;item&quot;&gt;213&lt;/div&gt;  &lt;/wb-list&gt;`,&#125;);Template.storyName = &quot;图片组件&quot;;// 配置组件的不同状态export const Normal = Template.bind(&#123;&#125;);Normal.args = &#123;  status: &quot;LOAD&quot;,  total: 100,&#125;;\n\n\n\n\n\n\n\n\n\n\n打包 storybook 项目\n1npm run build-storybook\n","slug":"StoryBook-为万表组件库提供文档说明","date":"2022-11-22T16:00:00.000Z","categories_index":"经验,Vue","tags_index":"Vue,组件库","author_index":"谢小谢"},{"id":"4ef67a396b8d10d036cface974a81940","title":"记一次多页面配置后CDN配置失效问题，查看cli源码并解决问题","content":"某天的某天，产品总监突然给我一个任务，让我在主站加一个页面。由于主站之前已经是 nodeJs 了，在原有基础上进行原生页面编写费时费力，且没有很大的 SEO 需求。所以我使用了上次商家入驻，在 Vue3 SPA 原来的基础上进行多页面开发。\nSPA 多页面配置的好处\n共享项目逻辑：作为新增加的页面，可以无缝地使用之前不相关业务的基建逻辑，如公用封装方法等。\nchunk 分离，业务分离，减少包大小：如果是在单入口的情况下增加一个新的路由，在主入口的 js 文件中势必会带上原有的部分业务逻辑，组件等。这样会增加请求时的包大小。\n自定义入口 TDK 有效，SEO 优化更精确\n\n开始配置这里主要是通过 vue.config.js 入口进行配置\n1234567891011121314151617181920212223242526272829303132// vue.config.js增加新配置项pages: &#123;  // 旧的商家入驻入口  index: &#123;    entry: &#x27;src/main.ts&#x27;,    template: &#x27;public/index.html&#x27;,    filename: &#x27;index.html&#x27;,    title: &#x27;Index Page&#x27;,    chunks: [&#x27;chunk-vendors&#x27;, &#x27;chunk-common&#x27;, &#x27;index&#x27;]  &#125;,  share: &#123;    entry: &#x27;src/share.ts&#x27;,    template: &#x27;public/share.html&#x27;,    filename: &#x27;share.html&#x27;,    title: &#x27;&#x27;,    chunks: [&#x27;chunk-vendors&#x27;, &#x27;chunk-common&#x27;, &#x27;share&#x27;]  &#125;&#125;,chainWebpack: config =&gt; &#123;  const cdn = &#123; .... &#125;  config    .plugin(&#x27;html&#x27;)    .use(HtmlWebpackPlugin)    .tap(args =&gt; &#123;      console.log(args);      args[0].cdn = cdn      args[0].chunksSortMode = &#x27;none&#x27;      // args.cdn = assetsCDN.assets;      return args    &#125;)&#125;\n\n当我信誓旦旦地准备看到绿色打印时，却报了一个 **TypeError: Cannot set properties of undefined (setting ‘cdn’)**的错误，于是，我打印了 args 的值，发现打印出来了一个空的数组。此时我做了一个猜想，重新使用了 HtmlWebpackPlugin 插件，会不会导致原有的配置被清空？\n带着疑问解决问题。于是，我看了看 vue-cli4 的源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130// 当我们运行vue-cli-service run serve 相当于直接调用以下指令new Service(...).run(&#x27;serve&#x27;)// 下面是主要运行过程的简化版代码module.exports = class Service &#123;  constructor (context, &#123; plugins, pkg, inlineOptions, useBuiltIn &#125; = &#123;&#125;) &#123;    process.VUE_CLI_SERVICE = this    // 初始化chainWebpack链式调用配置，存储所有的chainWebapck配置链    this.webpackChainFns = []    // 初始化webpackConfigure配置    this.webpackRawConfigFns = []    // 初始化所有的webpackChain链式    this.plugins = this.resolvePlugins(plugins, useBuiltIn)  &#125;  async run (name, args = &#123;&#125;, rawArgv = []) &#123;    this.init()    // 当指令为serve时 其实是调用了/vue-cli-4/packages/@vue/cli-service/lib/commands/serve.js里面的运行逻辑    const &#123; fn &#125; = command    return fn(args, rawArgv)  &#125;  init(mode) &#123;    // 应用所有plugins数组的插件插件    this.plugins.forEach((&#123; id, apply &#125;) =&gt; &#123;      if (this.pluginsToSkip.has(id)) return      apply(new PluginAPI(id, this), this.projectOptions)    &#125;)    if (this.projectOptions.chainWebpack) &#123;      this.webpackChainFns.push(this.projectOptions.chainWebpack)    &#125;  &#125;  resolvePlugins (inlinePlugins, useBuiltIn) &#123;    const idToPlugin = id =&gt; (&#123;      id: id.replace(/^.\\//, &#x27;built-in:&#x27;),      apply: require(id)    &#125;)    let plugins    // 每一个内置的js都按顺序require一次    const builtInPlugins = [      &#x27;./commands/serve&#x27;,      &#x27;...&#x27;, // 其他插件省略      &#x27;./config/app&#x27;    ].map(idToPlugin)    // 引入所有的内置插件文件，最后存储在this.plugins数组里面    const projectPlugins = Object.keys(this.pkg.devDependencies || &#123;&#125;)      .concat(Object.keys(this.pkg.dependencies || &#123;&#125;))      .filter(isPlugin)      .map(id =&gt; &#123;        if (          this.pkg.optionalDependencies &amp;&amp;          id in this.pkg.optionalDependencies        ) &#123;          let apply = () =&gt; &#123;&#125;          try &#123;            apply = require(id)          &#125; catch (e) &#123;            warn(`Optional dependency $&#123;id&#125; is not installed.`)          &#125;          return &#123; id, apply &#125;        &#125; else &#123;          return idToPlugin(id)        &#125;      &#125;)    plugins = builtInPlugins.concat(projectPlugins)    return plugins  &#125;  // 解析webpackChain  resolveChainableWebpackConfig () &#123;    const chainableConfig = new Config()    // config作为实例，链式调用所有方法，应用所有WebpackChain配置    this.webpackChainFns.forEach(fn =&gt; fn(chainableConfig))    return te  &#125;  // 在混合/vue-cli-4/packages/@vue/cli-service/lib/commands下的所有配置  resolveWebpackConfig (chainableConfig = this.resolveChainableWebpackConfig()) &#123;    // 所有chainWebpack配置初始化成webpackCompiler(options)模式    let config = chainableConfig.toConfig()    const original = config    // 和configureWebapck混合    this.webpackRawConfigFns.forEach(fn =&gt; &#123;      if (typeof fn === &#x27;function&#x27;) &#123;        // function with optional return value        const res = fn(config)        if (res) config = merge(config, res)      &#125; else if (fn) &#123;        // merge literal values        config = merge(config, fn)      &#125;    &#125;)    return config  &#125;&#125;// packages/@vue/cli-service/lib/PluginAPI.jsclass PluginAPI &#123;  constructor (id, service) &#123;    this.id = id    this.service = service  &#125;  resolveWebpackConfig (chainableConfig) &#123;    return this.service.resolveWebpackConfig(chainableConfig)  &#125;  chainWebpack (fn) &#123;    this.service.webpackChainFns.push(fn)  &#125;&#125;// vue-cli4/packages/@vue/cli-service/lib/commands/serve.js// 上面Sevice类的run方法最终调用了当前类的serve方法，在这里调用了新增Plugins的resolveWebpackConfig// 也就是Service类的resolveWebpackConfig方法module.exports = (api, options) =&gt; &#123;  api.registerCommand(&#x27;serve&#x27;, &#123;    ...    &#125;  &#125;, async function serve (args) &#123;    // resolve webpack config    const webpackConfig = api.resolveWebpackConfig()  &#125;)&#125;module.exports.defaultModes = &#123;  serve: &#x27;development&#x27;&#125;\n\n从上面代码就可以分析到，vue-cli 是按以下顺序来执行的，\n\nVue-cli 初始化时会使用所有&#x2F;cli-service&#x2F;lib&#x2F;commands，&#x2F;cli-service&#x2F;lib&#x2F;config 内的顺序来获取 webpackChain 的配置，塞入 Service 实例的 webpackChainFns 中。\n&#x2F;cli-service&#x2F;lib&#x2F;commands 内的插件一般是作为运行插件的，并不会像&#x2F;cli-service&#x2F;lib&#x2F;commands 内的插件一样，一直接调用就直接塞入 webpackChainFns，而是在 Plugins 具体调用内部函数的 registerCommand(‘serve’)注册为启动函数后，才会最终调用。\n我们在 vue.config.js 配置的 webpackChain 配置在代码逻辑中是在&#x2F;cli-service&#x2F;lib&#x2F;config 的 webpackChain 配置收集完才推入 webpackChainFns 中，这也印证了为什么我们的 html-webpack-plugin 配置之后，原来的多页&#x2F;单页配置会被覆盖掉。\n\n解决办法说了这么多，那究竟该怎么配置呢，有 2 种办法。\n\n一种就是在原来的 pages 项上加入 cdn 这个 key\n\n123456789101112131415161718192021222324252627282930// vue.config.js增加新配置项module.exports = &#123;  pages: &#123;    // 旧的商家入驻入口    index: &#123;      entry: &quot;src/main.ts&quot;,      ...其他参数省略,      cdn: &#123;        js: [          &quot;https://static.wbiao.co/libs/cdn/vue.global@3.0.11.js&quot;,          &quot;https://static.wbiao.co/libs/cdn/vue-router.global@4.0.6.js&quot;,          &quot;https://static.wbiao.co/libs/cdn/vuex.global@4.0.0.js&quot;,          &quot;https://static.wbiao.co/libs/cdn/axios.min.js&quot;,        ],      &#125;,    &#125;,    share: &#123;      entry: &quot;src/share.ts&quot;,      ...其他参数省略,      cdn: &#123;        js: [          &quot;https://static.wbiao.co/libs/cdn/vue.global@3.0.11.js&quot;,          &quot;https://static.wbiao.co/libs/cdn/vue-router.global@4.0.6.js&quot;,          &quot;https://static.wbiao.co/libs/cdn/vuex.global@4.0.0.js&quot;,          &quot;https://static.wbiao.co/libs/cdn/axios.min.js&quot;,        ],      &#125;,    &#125;,  &#125;,&#125;;\n\n\n第二种种就是重写 html-webpack-plugins 的 entry 的模板配置\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253module.exports = &#123;  pages: &#123;    index: &#123;      entry: &quot;src/main.ts&quot;,      chunks: [&quot;chunk-vendors&quot;, &quot;chunk-common&quot;, &quot;index&quot;],    &#125;,    share: &#123;      entry: &quot;src/share.ts&quot;,      chunks: [&quot;chunk-vendors&quot;, &quot;chunk-common&quot;, &quot;share&quot;],    &#125;,  &#125;,  chainWebpack: (config) =&gt; &#123;    const cdn = &#123;      js: [        &quot;https://static.wbiao.co/libs/cdn/vue.global@3.0.11.js&quot;,        &quot;https://static.wbiao.co/libs/cdn/vue-router.global@4.0.6.js&quot;,        &quot;https://static.wbiao.co/libs/cdn/vuex.global@4.0.0.js&quot;,        &quot;https://static.wbiao.co/libs/cdn/axios.min.js&quot;,      ],    &#125;;    config      .plugin(&quot;html&quot;)      .use(HtmlWebpackPlugin)      .tap((args) =&gt; &#123;        args[0] = &#123;          title: &quot;wanbiao&quot;,          cdn: cdn,          minify: &#123;            removeComments: true,            collapseWhitespace: true,            collapseBooleanAttributes: true,            removeScriptTypeAttributes: true,          &#125;,          template: path.resolve(__dirname, &quot;./public/index.html&quot;),        &#125;;        args[1] = &#123;          title: &quot;wb2&quot;,          cdn: cdn,          minify: &#123;            removeComments: true,            collapseWhitespace: true,            collapseBooleanAttributes: true,            removeScriptTypeAttributes: true,          &#125;,          template: path.resolve(__dirname, &quot;./public/share.html&quot;),        &#125;;        args[0].cdn = cdn;        args[0].chunksSortMode = &quot;none&quot;;        // args.cdn = assetsCDN.assets;        return args;      &#125;);  &#125;,&#125;;\n\n基础模板展示1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot; /&gt;    &lt;meta name=&quot;force-rendering&quot; content=&quot;webkit&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge,chrome=1&quot; /&gt;    &lt;link rel=&quot;icon&quot; href=&quot;/favicon.ico&quot; /&gt;    &lt;title&gt;&lt;%= process.env.VUE_APP_TITLE %&gt;&lt;/title&gt;    &lt;!-- 使用CDN的CSS文件 --&gt;    &lt;% for (var i in htmlWebpackPlugin.options.cdn &amp;&amp;    htmlWebpackPlugin.options.cdn.css) &#123; %&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%= htmlWebpackPlugin.options.cdn.css[i] %&gt;&quot; /&gt;    &lt;% &#125; %&gt;    &lt;!-- 使用CDN的JS文件 --&gt;    &lt;% for (var i in htmlWebpackPlugin.options.cdn &amp;&amp;    htmlWebpackPlugin.options.cdn.js) &#123; %&gt;    &lt;script      type=&quot;text/javascript&quot;      src=&quot;&lt;%= htmlWebpackPlugin.options.cdn.js[i] %&gt;&quot;    &gt;&lt;/script&gt;    &lt;% &#125; %&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;noscript&gt;      &lt;strong        &gt;We&#x27;re sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn&#x27;t work        properly without JavaScript enabled. Please enable it to        continue.&lt;/strong      &gt;    &lt;/noscript&gt;    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;    &lt;!-- built files will be auto injected --&gt;  &lt;/body&gt;&lt;/html&gt;\n","slug":"记一次多页面配置后CDN配置失效问题，查看cli源码并解决问题","date":"2022-03-13T16:00:00.000Z","categories_index":"经验,单页应用","tags_index":"vue,单页应用","author_index":"谢小谢"},{"id":"18236e9a0226f101897836af69d7e11a","title":"Webpack4优化之依赖包cdn加载优化","content":"记录一下自己项目使用 cdn 加速的具体过程，就是分离外部库的包(包括 vue, vue-router, vuex 等)，尽量只保留主要逻辑\n准备工作首先确定一下哪些包需要进行分离，这里我们主要 Vue 的周边库，利用 html-plugin-webpack 插件，插入到 script 标签之中\n开始配置 webpack首先配置 html-webpack-plugin 和 webpack 的 externals 属性，防止打包时将要分离的库一起打包进去，这里使用 chainWebpack 插件，\n12345678910111213const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);config.externals(&#123; vue: &quot;Vue&quot;, &quot;vue-router&quot;: &quot;VueRouter&quot;, vuex: &quot;Vuex&quot; &#125;);config.plugin(&quot;html-webpack-plugin&quot;).use(  new HtmlWebpackPlugin(&#123;    cdnJsModule: [      &quot;https://lib.baomitu.com/vue/3.0.7/vue.runtime.global.js&quot;,      &quot;https://lib.baomitu.com/vue-router/4.0.4/vue-router.global.prod.js&quot;,      &quot;https://lib.baomitu.com/vuex/4.0.0/vuex.global.prod.min.js&quot;,    ],    template: &quot;template/loading.html&quot;, // 重写div=app  &#125;));\n\n可以看到 htmlwebpackplugin 配置了 cdnjsModule 这个属性，后续在定制的 loading.html 模板里面写入\n123456789&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot; /&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;&lt;% for (var i in htmlWebpackPlugin.options.cdnJsModule) &#123; %&gt;&lt;script src=&quot;&lt;%= htmlWebpackPlugin.options.cdnJsModule[i] %&gt;&quot;&gt;&lt;/script&gt;&lt;% &#125; %&gt;&lt;/head&gt; ...\n\n打包对比 现在看看，配置前后的打包情况，可见减少了差不多 100K 左右的大小1234567// 未配置前server/js/chunk-vendors.3e815d2d.js 144.96 KiB   52.24 KiBserver/js/app.3ad30f1e.js 46.88 KiB        12.06 KiB// 配置后server/js/app.941edfa5.js   50.58 KiB 12.30 KiBserver/js/chunk-vendors.0c15f71f.js    50.22 KiB    18.02 KiB\n","slug":"Webpack4优化之依赖包cdn加载优化","date":"2022-03-04T16:00:00.000Z","categories_index":"webpack,总结,Vue","tags_index":"webpack","author_index":"谢小谢"},{"id":"8244f2f98fb7537fa6df6a08feffa028","title":"Vue3源码 实例初始化过程详解","content":"自己接触 Vue3 也有一段时间了 之前一直有看相关的源码，现在总结下 creatApp 到 mount 挂载中间发生了什么\n\n\n\n\n\n\n\n\n\n下面的代码均为精简版 删掉了部分不相关的代码\n查看入口文档123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158// vue-next/packages/runtime-dom/src/index.ts/*   nodeOps: packages/runtime-dom/src/nodeOps.ts   patchProp: packages/runtime-dom/src/patchProp.ts   renderOptions为 合并nodeOps和patchProp对象， 为后面vnode的patch操作提供一系列更新dom和内部属性的方法 */const rendererOptions = extend(&#123; patchProp, forcePatchProp &#125;, nodeOps)  let renderer: Renderer&lt;Element&gt; | HydrationRenderer/*   1.判断renderer值 实质上是执行了 packages/runtime-core/src/renderer.ts的 baseCreateRenderer里面所返回对象的里面的createApp方法 */function ensureRenderer() &#123;   return renderer || (renderer = createRenderer&lt;Node, Element&gt;(rendererOptions)) &#125;// 标准化组件function normalizeContainer(  container: Element | ShadowRoot | string ): Element | null &#123;  if (isString(container)) &#123;    const res = document.querySelector(container)    if (__DEV__ &amp;&amp; !res) &#123;      warn(`Failed to mount app: mount target selector &quot;$&#123;container&#125;&quot; returned null.`)    &#125;    return res  &#125;  return container as any&#125;export const createApp = (...args) =&gt; &#123;  // 实际调用了packages/runtime-core/src/apiCreateApp.ts的createAppAPI方法(柯里化函数)返回的createApp  const app = ensureRenderer().createApp(...args);  const &#123; mount &#125; = app;  app.mount = (containerOrSelector: Element | ShadowRoot | string): any =&gt; &#123;    // 判断是否是真实的dom 如果不是就通过document.querySelector获取    // 找不到就会报警告    const container = normalizeContainer(containerOrSelector);    // 没有找到dom节点就直接退出函数    if (!container) return;    const component = app._component;    if (!isFunction(component) &amp;&amp; !component.render &amp;&amp; !component.template) &#123;      component.template = container.innerHTML;    &#125;    // 挂载前清空内容    container.innerHTML = &quot;&quot;;    // 执行挂载dom操作    const proxy = mount(container);    if (container instanceof Element) &#123;      container.removeAttribute(&quot;v-cloak&quot;);      container.setAttribute(&quot;data-v-app&quot;, &quot;&quot;);    &#125;    // 返回vnode的proxy对象    return proxy;  &#125;;&#125;;export function createAppContext(): AppContext &#123;  return &#123;    app: null as any,    config: &#123;      isNativeTag: NO,      performance: false,      globalProperties: &#123;&#125;,      optionMergeStrategies: &#123;&#125;,      isCustomElement: NO,      errorHandler: undefined,      warnHandler: undefined,    &#125;,    mixins: [],    components: &#123;&#125;,    directives: &#123;&#125;,    provides: Object.create(null),  &#125;;&#125;export function createAppAPI&lt;HostElement&gt;(   render: RootRenderFunction,   hydrate?: RootHydrateFunction ): CreateAppFunction&lt;HostElement&gt; &#123;  // 返回一个app实例对象  const context = createAppContext()  // 创建一个存储所有插件的数组  const installedPlugins = new Set()  // 当前dom是否已经挂载  let isMounted = false  // 初始化app实例  const app: App = (context.app = &#123;    _uid: uid++,      _component: rootComponent as ConcreteComponent,      _props: rootProps,      _container: null,      _context: context,      version,      get config() &#123;        return context.config      &#125;  &#125;);  // 初始化use方法 供插件使用  use(plugin: Plugin, options: any[]) &#123;&#125;    component(name: string, component?: Component): any &#123;    if (__DEV__) &#123;      validateComponentName(name, context.config);    &#125;    if (!component) &#123;      return context.components[name];    &#125;    if (__DEV__ &amp;&amp; context.components[name]) &#123;      warn(`Component &quot;$&#123;name&#125;&quot; has already been registered in target app.`);    &#125;    // 添加到执行上下文    context.components[name] = component;    return app;  &#125;,  // 初始化全局指令方法  directive(name: string, directive?: Directive) &#123;    if (__DEV__) &#123;      validateDirectiveName(name);    &#125;    if (!directive) &#123;      return context.directives[name] as any;    &#125;    // 添加到执行上下文    context.directives[name] = directive;    return app;  &#125;,  // 初始化实例写在方法  unmount() &#123;    if (isMounted) &#123;      // 清空节点      render(null, app._container);      if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) &#123;        devtoolsUnmountApp(app);      &#125;    &#125;  &#125;,  // 根实例提供方法注入  provide(key, value) &#123;    context.provides[key as string] = value;    return app;  &#125;,  // 初始化节点挂载  mount(rootContainer: HostElement, isHydrate?: boolean): any &#123;    // 没有挂载情况下会根据传入的组件创建vnode节点    if (!isMounted) &#123;      const vnode = createVNode(        // createApp传进来的组件创建了一个虚拟dom        rootComponent as ConcreteComponent,        rootProps      );      vnode.appContext = context;      // 是否是服务端渲染      if (isHydrate &amp;&amp; hydrate) &#123;      &#125; else &#123;        // 如果不是服务端渲染的话 调用渲染函数渲染到挂载dom里面        render(vnode, rootContainer);      &#125;      // 挂载标识改变      isMounted = true;      // app实例 创建挂载点标识      app._container = rootContainer;      // for devtools and telemetry      (rootContainer as any).__vue_app__ = app;      if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) &#123;        devtoolsInitApp(app, version);      &#125;      return vnode.component!.proxy;    &#125; else if (__DEV__) &#123;      // 开发环境下重复挂载报警    &#125;  &#125;&#125;\n\n总结\n\n\n\n\n\n\n\n\n从上图可知, ensureRenderer().createApp(…args)实际上直接调用了 createAppAPI 的 createApp 后，重写了 app 的 mount 方法，至于为什么要重写 mount 方法，主要还是应对后面的跨平台改造，mount 作为一个独立的跨平台处理函数，不应该带有特定的平台的逻辑，而这里仅仅针对 web，挂载前清空容器内容则是为了防止其他异常情况导致保存了该段代码，那么下面就分析下 createApp 做了什么 下面是主要源码注释\n1// packages/runtime-core/src/apiCreateApp.ts\n\n总结\n\n\n\n\n\n\n\n\ncreateApp 里面创建了 context 实例，并且为 context 里面的 app 属性初始化了 use 方法提供全局插件挂载，mixin 方法提供全局逻辑混入，component 方法提供全局组件注册，directive 提供全局指令注册，mount,unmount 提供组件挂载&#x2F;卸载功能等。同时将这个 4 个方法赋予 context,将 contxt 自己挂载在 app 属性的\\_context 执行上下文中，并将其赋值给了一个新的 app 常量返回出去, mount 方法里面执行了 vnode 建立 &#x3D;&gt; vnode 渲染的过程，最终交给 render 函数通过底层的 dom 操作插入到 rootContainer 里面，至于 render 函数的详细执行过程，给我一点时间整理。\n","slug":"Vue3源码 实例初始化过程详解","date":"2022-02-23T16:00:00.000Z","categories_index":"Vue,总结,Vue源码","tags_index":"Vue3","author_index":"谢小谢"},{"id":"b5ff54a9d086ee4b944aa5321b46f563","title":"Vue2.6系列源码解析之Keep-Alive组件的缓存逻辑","content":"对于很多用过 vue 这个框架的人来说，想必都用过 keep-alive 组件缓存功能。vue 内部使用了 LRU 缓存淘汰算法来实现组件的缓存更新问题，那 vue 是如何实现这个 keep-alive 组件的逻辑呢，我们来解析一下。\n源码解读123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153// 获取vnode实例名称function getComponentName(opts: ?VNodeComponentOptions): ?string &#123;  return opts &amp;&amp; (opts.Ctor.options.name || opts.tag);&#125;// 匹配当前队列里面是否存在该vnodefunction matches(  pattern: string | RegExp | Array&lt;string&gt;,  name: string): boolean &#123;  if (Array.isArray(pattern)) &#123;    return pattern.indexOf(name) &gt; -1;  &#125; else if (typeof pattern === &quot;string&quot;) &#123;    return pattern.split(&quot;,&quot;).indexOf(name) &gt; -1;  &#125; else if (isRegExp(pattern)) &#123;    return pattern.test(name);  &#125;  return false;&#125;// 实例筛选function pruneCache(keepAliveInstance: any, filter: Function) &#123;  const &#123; cache, keys, _vnode &#125; = keepAliveInstance;  for (const key in cache) &#123;    const entry: ?CacheEntry = cache[key];    if (entry) &#123;      const name: ?string = entry.name;      if (name &amp;&amp; !filter(name)) &#123;        pruneCacheEntry(cache, key, keys, _vnode);      &#125;    &#125;  &#125;&#125;function pruneCacheEntry(  cache: CacheEntryMap,  key: string,  keys: Array&lt;string&gt;,  current?: VNode) &#123;  const entry: ?CacheEntry = cache[key];  if (entry &amp;&amp; (!current || entry.tag !== current.tag)) &#123;    entry.componentInstance.$destroy();  &#125;  cache[key] = null;  remove(keys, key);&#125;export default &#123;  name: &quot;keep-alive&quot;,  abstract: true,  props: &#123;    include: patternTypes,    exclude: patternTypes,    max: [String, Number],  &#125;,  methods: &#123;    // 虚拟dom缓存    cacheVNode() &#123;      const &#123; cache, keys, vnodeToCache, keyToCache &#125; = this;      // 如果存在等待被缓存的vnode 就要缓存起来      if (vnodeToCache) &#123;        const &#123; tag, componentInstance, componentOptions &#125; = vnodeToCache;        cache[keyToCache] = &#123;          name: getComponentName(componentOptions),          tag,          componentInstance,        &#125;;        // 推vnode的key进入缓存组        keys.push(keyToCache);        // 如果缓存组件有最大数量限制的情况下 并且超大最大缓存数量限制，那么就删除缓存队列的第一项        // pruneCacheEntry 判断了当前的缓存队列的第一项是 如果跟新进来的最新vnode是否一致，        // 不一致的情况下就直接卸载当前第一项的实例，一致就保存不进行卸载进行复用操作        if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) &#123;          pruneCacheEntry(cache, keys[0], keys, this._vnode);        &#125;        this.vnodeToCache = null;      &#125;    &#125;,  &#125;,  created() &#123;    // 存储所有组件    this.cache = Object.create(null);    // 存储所有组件的cid值 源码里面是逐步递增的    this.keys = [];  &#125;,  destroyed() &#123;    // 卸载时删除所有缓存的组件实例    for (const key in this.cache) &#123;      pruneCacheEntry(this.cache, key, this.keys);    &#125;  &#125;,  mounted() &#123;    // 开始缓存当前实例    this.cacheVNode();    // 监听include和exclude队列，去除里面不匹配的的组件    this.$watch(&quot;include&quot;, (val) =&gt; &#123;      pruneCache(this, (name) =&gt; matches(val, name));    &#125;);    this.$watch(&quot;exclude&quot;, (val) =&gt; &#123;      pruneCache(this, (name) =&gt; !matches(val, name));    &#125;);  &#125;,  updated() &#123;    // 更新的时候同步更新当前vnode    this.cacheVNode();  &#125;,  render() &#123;    const slot = this.$slots.default;    const vnode: VNode = getFirstComponentChild(slot);    const componentOptions: ?VNodeComponentOptions =      vnode &amp;&amp; vnode.componentOptions;    // 如果存在组件实例    if (componentOptions) &#123;      // check pattern      const name: ?string = getComponentName(componentOptions);      const &#123; include, exclude &#125; = this;      // 如果不缓存的列表有当前vnode或者缓存列表没有当前vnode 那么就直接返回该节点      if (        (include &amp;&amp; (!name || !matches(include, name))) ||        (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))      ) &#123;        return vnode;      &#125;      // 到这里就说明当前组件是需要缓存的      const &#123; cache, keys &#125; = this;      const key: ?string =        vnode.key == null          ? componentOptions.Ctor.cid +            (componentOptions.tag ? `::$&#123;componentOptions.tag&#125;` : &quot;&quot;)          : vnode.key;      // 如果当前组件被缓存过 那么就更新当前组件 把组件推到缓存队列key的最后边，      // 这样就能总是获取到最新的更新项 LRU算法      if (cache[key]) &#123;        // 复用缓存        vnode.componentInstance = cache[key].componentInstance;        remove(keys, key);        keys.push(key);      &#125; else &#123;        this.vnodeToCache = vnode;        this.keyToCache = key;      &#125;      vnode.data.keepAlive = true;    &#125;    return vnode || (slot &amp;&amp; slot[0]);  &#125;,&#125;;\n\n说说 LRU 缓存淘汰算法LRU 算法，即最近最久未使用，是一种非常常见的缓存淘汰算法。算法的设计原则： 如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。也就是说，当限定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。\n下面是我自己画的 keep-alive 缓存淘汰算法的流程示意图例，辅助查看\n\n","slug":"Vue2.6系列源码解析之Keep-Alive组件的缓存逻辑2022-02-03","date":"2022-02-02T16:00:00.000Z","categories_index":"Vue,总结,Vue源码","tags_index":"Vue","author_index":"谢小谢"},{"id":"d808854a301e8b255f9b814d0115997a","title":"Vue2.6源码解析之diff算法更新过程及其相关问题","content":"每次面试都会被面试官问到 diff 算法，每次都看别人文章，过了就忘。最近抽空自己看看源码，自己在不借助其他人文章思路的情况下，自己死磕源码，总结出自己的一些心得，ps：下次再也不用一直找别人文章看\n从问题说起？\ndiff 算法是怎么对比的？\n遇到了 v-for 绑定的 key 值为 index 导致删除列表的某一项，删除的却是始终是最后一项的情况。\n没绑定 index，删除后也会出现始终删除最后一项的问题。\n官网说的默认使用旧地复用在哪里体现？\n\n具体看下图代码\n123456789101112131415161718192021222324252627282930313233343536373839404142&lt;div class=&quot;content-body&quot;&gt;  &lt;ul&gt;    &lt;li v-for=&quot;(item,index) in selectionConditionList&quot; :key=&quot;index&quot;&gt;      &lt;v-selection-condition-list&gt;&lt;/v-selection-condition-list&gt;      &lt;button @click=&quot;deleteSelectionCondition(index)&quot;&gt;删除&lt;/button&gt;    &lt;/li&gt;  &lt;/ul&gt;  &lt;button @click=&quot;addNewSelectionTask&quot;&gt;新建任务&lt;/button&gt;&lt;/div&gt;&lt;script&gt;  const vSelectionConditionList = &#123;    data() &#123;      return &#123;        inputName: Math.random(),      &#125;;    &#125;,    template: `&lt;input type=&quot;text&quot; :value=&quot;inputName&quot;&gt;`,  &#125;;  var app = new Vue(&#123;    el: &quot;.content-body&quot;,    data() &#123;      return &#123;        selectionConditionList: [],      &#125;;    &#125;,    methods: &#123;      // 添加      addNewSelectionTask() &#123;        this.selectionConditionList.push(&#123;&#125;);      &#125;,      // 删除      deleteSelectionCondition(index) &#123;        console.log(&quot;delete..&quot; + index);        this.selectionConditionList.splice(index, 1);      &#125;,    &#125;,    components: &#123;      vSelectionConditionList,    &#125;,  &#125;);&lt;/script&gt;\n\n解决问题先看看源码下面代码会去掉一些非核心的代码\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165// src/core/vdom/patch.jsfunction updateChildren(  parentElm,  oldCh,  newCh,  insertedVnodeQueue,  removeOnly) &#123;  let oldStartIdx = 0; // 旧起始标记 默认0  let newStartIdx = 0; // 新起始标记 默认0  let oldEndIdx = oldCh.length - 1; // 旧的最后一个的索引  let oldStartVnode = oldCh[0]; // 旧的第一个节点  let oldEndVnode = oldCh[oldEndIdx]; // 旧的最后一个节点  let newEndIdx = newCh.length - 1; // 新的最后一个的索引  let newStartVnode = newCh[0]; // 新的第一个节点  let newEndVnode = newCh[newEndIdx]; // 新的最后一个节点  let oldKeyToIdx, idxInOld, vnodeToMove, refElm;  // removeOnly是一个特殊标志，仅由&lt;transition group&gt;使用，以确保在离开转换期间被删除的元素保持在正确的相对位置  const canMove = !removeOnly;  // 判断新节点是否存在重复的key  if (process.env.NODE_ENV !== &quot;production&quot;) &#123;    checkDuplicateKeys(newCh);  &#125;  // 起始对比  // 当旧起始index小于等于旧的旧的结束index 并且 新起始小于等于新结束index  while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;    // 如果旧起始节点未定义    if (isUndef(oldStartVnode)) &#123;      // 旧起始节点下标进1位 +1      oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left    &#125; else if (isUndef(oldEndVnode)) &#123;      // 如果旧的结束节点未定义 那么下标就退一位 -1      oldEndVnode = oldCh[--oldEndIdx];    &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123;      // 如果新旧起始节点是同个节点 那么就进行下一层的对比 并且两者下标都进一位 +1      patchVnode(        oldStartVnode,        newStartVnode,        insertedVnodeQueue,        newCh,        newStartIdx      );      oldStartVnode = oldCh[++oldStartIdx];      newStartVnode = newCh[++newStartIdx];    &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123;      // 如果新旧结束节点是同个节点 那么就进行下一层的对比 并且两者下标都退一位 1      patchVnode(        oldEndVnode,        newEndVnode,        insertedVnodeQueue,        newCh,        newEndIdx      );      oldEndVnode = oldCh[--oldEndIdx];      newEndVnode = newCh[--newEndIdx];    &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123;      // 如果旧起始节点和新结束是同个节点，那么进行下一层对比 旧起始进一位+1 新起始节点退一位-1      // 并且把 那么就把旧起始节点插入到旧结束节点的前面      // Vnode moved right      patchVnode(        oldStartVnode,        newEndVnode,        insertedVnodeQueue,        newCh,        newEndIdx      );      canMove &amp;&amp;        nodeOps.insertBefore(          parentElm,          oldStartVnode.elm,          nodeOps.nextSibling(oldEndVnode.elm)        );      oldStartVnode = oldCh[++oldStartIdx];      newEndVnode = newCh[--newEndIdx];    &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123;      // 如果旧结束和新起始是同个节点，那么进行下一层对比 旧结束退一位-1 新起始节点进一位+1      // 并且把 那么就把旧起始节点插入到旧结束节点的位置      // Vnode moved left      patchVnode(        oldEndVnode,        newStartVnode,        insertedVnodeQueue,        newCh,        newStartIdx      );      canMove &amp;&amp;        nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);      oldEndVnode = oldCh[--oldEndIdx];      newStartVnode = newCh[++newStartIdx];    &#125; else &#123;      // 如果旧数据没有绑定key值      if (isUndef(oldKeyToIdx))        // oldKeyToIdx存储当前旧数据区间的key值为key当前的索引        oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);      // 如果当前新数据有key的话  idxInOld就等于oldKeyToIdx的key项的索引      // findIdxInOld拿当前新开始节点，通过判断旧起始-结束节点之中有没有其位置，找出当前新开始在旧中的位置      // 无key情况下      //    如果新节点不存在于旧节点中，那么就作为新增节点加入插入到oldStartNode前面      // 有key情况下 直接获取当前节点在旧的之前的位置      idxInOld = isDef(newStartVnode.key)        ? oldKeyToIdx[newStartVnode.key]        : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);      // 如果如果没有index 那么就直接创建元素      if (isUndef(idxInOld)) &#123;        // 如果没有找到 那么就在当前索引前面插入新元素        createElm(          newStartVnode,          insertedVnodeQueue,          parentElm,          oldStartVnode.elm,          false,          newCh,          newStartIdx        );      &#125; else &#123;        // 有index就直接复用元素        vnodeToMove = oldCh[idxInOld];        // 同元素情况下        if (sameVnode(vnodeToMove, newStartVnode)) &#123;          patchVnode(            vnodeToMove,            newStartVnode,            insertedVnodeQueue,            newCh,            newStartIdx          );          oldCh[idxInOld] = undefined;          // 在前面插入          canMove &amp;&amp;            nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);        &#125; else &#123;          // same key but different element. treat as new element          createElm(            newStartVnode,            insertedVnodeQueue,            parentElm,            oldStartVnode.elm,            false,            newCh,            newStartIdx          );        &#125;      &#125;      newStartVnode = newCh[++newStartIdx];    &#125;  &#125;  // 如果对比完成  // 如果旧起始大于旧结束 说明新的里面的东西都是新增的 就加入  if (oldStartIdx &gt; oldEndIdx) &#123;    refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;    addVnodes(      parentElm,      refElm,      newCh,      newStartIdx,      newEndIdx,      insertedVnodeQueue    );  &#125; else if (newStartIdx &gt; newEndIdx) &#123;    // 如果新开始大于新结束，那说明旧的里面的dom是被删除 就移除调    removeVnodes(oldCh, oldStartIdx, oldEndIdx);  &#125;&#125;\n\ndiff 算法是怎么 diff？下面用一个例子来做一层模拟 更直观地展示，上方为 oldVnode，下方为 newVnode，key 为内容数字，且唯一\n\nStep1: 新头旧头，新尾旧尾，新头旧尾，新尾旧头对比后，发现并不一致，进入源码中的最后一个 else 内部，进入之后oldKeyToIdx 为 undefined，初始化 oldKeyToIdx 的值。因为 newStartVnode 有值，idxInOld &#x3D; oldKeyToIdx[newStartVnode.key]等于 1，调用 createElement 在 oldStartVnode 前面插入 newStartVnode，newStartIndex++。此时 oldStartIndex：0,oldEndIndex：2，newStartIndex：1，newEndIndex：3\n\nStep2: 新头旧头对比后发现都为 1，一致 newStartIndex,oldStartIndex 都+1，当前层不进行复用&#x2F;排列操作，保存本位。此时 oldStartIndex：1,oldEndIndex：2，newStartIndex：2，newEndIndex：3\n\nStep3: 旧尾新头对比后发现都为 3，newStartIndex+1，oldEndIndex-1，此时 oldStartIndex：1,oldEndIndex：1，newStartIndex：3，newEndIndex：3\n\nStep3: 头尾相比发现都不一致，进入 else 内部，oldKeyToIdx 数组内部没有第 4 个的值 所以在 newStartIndex 前面插入 4，newStartIdx+1，此时 newStartIndex &gt; newOldIndex,就移除旧数组的 oldStartIdx 到 oldEndIdx 的 vnode，也就是 2，最后返回 2134\n从上图源码来看，可以得出，diff 算法会依照固定的判断同层级 Vnode 的顺序进行头头，尾尾，头尾，尾头的比较不断收缩 4 个定义的下标的位置来进行 dom 的重排和复用操作\n解决第 2，3 个问题,探究下本质为什么会出现 key 绑定为 index，或者不绑定情况下删除会删除最后一项问题呢，这其实涉及到了 vnode 的渲染原理\n\n假如按照上面代码通过调用编译后的 render 函数调用 _l 方法也就是 renderList 调用 createElement 方法初始化了多个 vnode，在绑定 key 为 index 的情况下 增加 3 个删除第一个，打印 vnode 大概是这样的，\n\n123456789101112131415/*旧vnodechildren: Array(3)0: VNode &#123;tag: &quot;li&quot;, data: &#123;…&#125;, children: Array(3), text: undefined, key: 0, …&#125;1: VNode &#123;tag: &quot;li&quot;, data: &#123;…&#125;, children: Array(3), text: undefined, key: 1, …&#125;2: VNode &#123;tag: &quot;li&quot;, data: &#123;…&#125;, children: Array(3), text: undefined, key: 2, …&#125;*/*新vnodechildren: Array(2)0: VNode &#123;tag: &quot;li&quot;, data: &#123;…&#125;, children: Array(3), text: undefined, key: 0, …&#125;1: VNode &#123;tag: &quot;li&quot;, data: &#123;…&#125;, children: Array(3), text: undefined, key: 1, …&#125;*/\n\n由上可知，key 是不变的，但是实际上 dom 内容已经变了。这就会导致在头头对比之中因为双方 key 一致，从而判断为同个 vnode，会使 newStartIdx 和 oldStartIndex 一致向右进 1, 最后 newStarteIndex &gt; newEndIndex, 导致 oldStartIndex 到 oldEndIndex 之间的 vnode 被删除，所以这才会出现删除的总是最后一项的情况。没有绑定 key 时情况也是如此。具体如下图所示\n\n解决第 4 个问题，就地复用在哪里得到体现？源码中，如果新的节点在旧的节点列表上有出现的 ，那么就会存储当前 Vnode，直接插入到 dom 前面，复用旧 Vnode，不创建新的 dom。如下源码：\n1234567891011121314151617function updateChildren() &#123;  // 拿到旧代码 直接存储  vnodeToMove = oldCh[idxInOld];  if (sameVnode(vnodeToMove, newStartVnode)) &#123;    patchVnode(      vnodeToMove,      newStartVnode,      insertedVnodeQueue,      newCh,      newStartIdx    );    oldCh[idxInOld] = undefined;    // 在前面插入    canMove &amp;&amp;      nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);  &#125;&#125;\n\n\n\n\n\n\n\n\n\n\n以上就是我看源码得出的结论，有疑问的小伙伴可以在下方留言。thanks！！！\n","slug":"Vue2.6源码解析之diff算法更新过程及其相关问题","date":"2021-12-25T16:00:00.000Z","categories_index":"Vue,总结,Vue源码","tags_index":"Vue","author_index":"谢小谢"},{"id":"92857319a9a1729d512b153f0e035994","title":"总结下前段时间公司项目中的Better-scroll封装","content":"总结下自己前一段时间公司项目使用 Better-scroll 进行总体封装，集成下拉刷新,上拉加载等\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167&lt;template&gt;  &lt;div class=&quot;wrapper&quot; :ref=&quot;refUuid&quot;&gt;    &lt;div class=&quot;wrapper--content&quot; :ref=&quot;`$&#123;refUuid&#125;Content`&quot;&gt;      &lt;div class=&quot;pulldown-wrapper&quot; v-if=&quot;pulldown&quot;&gt;        &lt;div v-show=&quot;beforePullDown&quot;&gt;&lt;span&gt;下拉刷新&lt;/span&gt;&lt;/div&gt;        &lt;div v-show=&quot;!beforePullDown&quot;&gt;          &lt;div v-show=&quot;isPullingDown&quot;&gt;            &lt;van-loading size=&quot;24px&quot; type=&quot;spinner&quot;&gt;加载中...&lt;/van-loading&gt;          &lt;/div&gt;          &lt;div v-show=&quot;!isPullingDown&quot;&gt;&lt;span&gt;刷新成功&lt;/span&gt;&lt;/div&gt;        &lt;/div&gt;      &lt;/div&gt;      &lt;slot&gt;&lt;/slot&gt;      &lt;div        class=&quot;pullup-wrapper&quot;        v-if=&quot;pullup &amp;&amp; showPullup &amp;&amp; showHasMoreScreen&quot;      &gt;        &lt;div v-if=&quot;!isPullUpLoad&quot; class=&quot;before-trigger&quot;&gt;          &lt;span class=&quot;pullup-txt&quot;&gt;上拉刷新&lt;/span&gt;        &lt;/div&gt;        &lt;div v-else class=&quot;after-trigger&quot;&gt;          &lt;van-loading size=&quot;24px&quot; type=&quot;spinner&quot; v-if=&quot;hasMore&quot;            &gt;加载中...&lt;/van-loading          &gt;          &lt;span v-else&gt;没有更多了。。。。。&lt;/span&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import BScroll from &quot;better-scroll&quot;;import &#123; v4 as uuidv4 &#125; from &quot;uuid&quot;;export default &#123;  data() &#123;    return &#123;      scroll: null,      refUuid: uuidv4(),      showPullup: true, // 是否展示加载更多栏目    &#125;;  &#125;,  props: &#123;    /**     * 1 滚动的时候会派发scroll事件，会截流。     * 2 滚动的时候实时派发scroll事件，不会截流。     * 3 除了实时派发scroll事件，在swipe的情况下仍然能实时派发scroll事件     */    probeType: &#123; type: Number, default: 1 &#125;, // 点击列表是否派发click事件    click: &#123; type: Boolean, default: true &#125;, // 是否开启横向滚动    scrollX: &#123; type: Boolean, default: false &#125;, // 是否派发滚动到底部的事件，用于上拉加载    pullup: &#123; type: Boolean, default: false &#125;, // 是否派发顶部下拉的事件，用于下拉刷新    pulldown: &#123; type: Boolean, default: false &#125;, // 刷新的时延    refreshDelay: &#123; type: Number, default: 20 &#125;, // 数据源    data: &#123; type: [Array, Object], default: null &#125;, // 开始下拉    beforePullDown: &#123; type: Boolean, default: true &#125;, // 下拉中    isPullingDown: &#123; type: Boolean, default: false &#125;, // 上拉中    isPullUpLoad: &#123; type: Boolean, default: false &#125;, // 是否有更多数据    hasMore: &#123; type: Boolean, default: true &#125;, // 是否展示底部的加载更多数据    showHasMoreScreen: &#123; type: Boolean, default: true &#125;,  &#125;,  mounted() &#123;    this.$nextTick(() =&gt; &#123;      setTimeout(() =&gt; &#123;        this.initBetterScroll();        this.refreshPullRegion();        this.refreshScrollXRegion();      &#125;, 10);      setTimeout(() =&gt; &#123;        this.initcroll();      &#125;, 10);    &#125;);  &#125;,  watch: &#123;    // 监听数据的变化，延时 refreshDelay 时间后调用 refresh 方法重新计算，保证滚动效果正常    data() &#123;      setTimeout(() =&gt; &#123;        this.refresh();      &#125;, this.refreshDelay);    &#125;,  &#125;,  methods: &#123;    // 判断滚动区域是否大于呈现区域 如果大于 就不可能出现上拉刷新显示区    refreshPullRegion() &#123;      if (        this.$refs[this.refUuid].clientHeight &gt;        this.$refs[`$&#123;this.refUuid&#125;Content`].clientHeight      ) &#123;        this.showPullup = false;      &#125; else &#123;        this.showPullup = true;      &#125;      console.log(&quot;----结束&quot;, this.showPullup);    &#125;,    refreshScrollXRegion() &#123;      if (this.scrollX) &#123;        this.$refs[`$&#123;this.refUuid&#125;Content`].style.position = &quot;absolute&quot;;      &#125;    &#125;,    initBetterScroll() &#123;      // 没有就为空      if (!this.$refs[this.refUuid]) return;      const config = &#123;&#125;;      if (this.pulldown) &#123;        config.pullDownRefresh = &#123; stop: 56, threshold: 70 &#125;;      &#125;      if (this.pullup) &#123;        config.pullUpLoad = true;      &#125;      if (this.scrollX) &#123;        config.scrollX = true;      &#125;      // 开始初始化      this.scroll = new BScroll(this.$refs[this.refUuid], &#123;        click: true,        scrollY: true,        observeDOM: true,        ...config,      &#125;);      // 如果有开启下拉 就监听下拉事件      if (this.pulldown) &#123;        this.scroll.on(&quot;pullingDown&quot;, async () =&gt; &#123;          this.$emit(&quot;pulldown&quot;);        &#125;);      &#125;      // 如果有开启上拉 就监听上拉事件      if (this.pullup) &#123;        this.scroll.on(&quot;pullingUp&quot;, async () =&gt; &#123;          this.$emit(&quot;pullup&quot;);        &#125;);      &#125;    &#125;,    refresh() &#123;      if (this.pullup) &#123;        this.scroll.finishPullUp();      &#125;      this.scroll &amp;&amp; this.scroll.refresh();      this.refreshPullRegion();      this.refreshScrollXRegion();    &#125;,  &#125;,&#125;;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.wrapper &#123;  flex: 1;  overflow: hidden;  position: relative;  &amp;--content &#123;    z-index: 2;    .pulldown-wrapper &#123;      position: absolute;      width: 100%;      padding: 20px;      box-sizing: border-box;      transform: translateY(-100%) translateZ(0);      text-align: center;      color: #999;    &#125;    .pullup-wrapper &#123;      padding: 20px;      text-align: center;      color: #999;    &#125;  &#125;&#125;&lt;/style&gt;\n","slug":"总结下前段时间公司项目中的Better-scroll封装","date":"2021-12-21T16:00:00.000Z","categories_index":"vue,经验","tags_index":"better-scroll,vue","author_index":"谢小谢"},{"id":"d36c9246f4e0462addbf95d33343891c","title":"Vue.2.6源码分析之事件挂载和双向绑定原理","content":"对于用 vue 的小伙伴来说，v-model 是 vue 开发过程中使用非常频繁的一个指令，它实现了数据的双向绑定。那么现在，我们就来探究一下发生双向绑定的过程是如何实现的\n设想一下绑定过程我们都知道，传入 data 的数据会被 Object.defineProperty 转化成 getter,setter进行监听，v-model 则是需要 input 框支持。当 input 输入时，view 层的数据也会随之动态改变，那么很明显是需要通过一个事件监听方法来触发的。当数据层被触发时，响应，那事件监听事件是在啥时候就开始挂载事件的呢?\n看看源码中事件怎么监听的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106// src\\\\platforms\\\\web\\\\compiler\\\\directives\\\\model.jsfunction genDefaultModel(  el: ASTElement,  value: string,  modifiers: ?ASTModifiers): ?boolean &#123;  const type = el.attrsMap.type;  const &#123; lazy, number, trim &#125; = modifiers || &#123;&#125;;  // 没有携带lazy修饰符并且input类型伟range时就需要进行compsition检测  const needCompositionGuard = !lazy &amp;&amp; type !== &quot;range&quot;;  // 1.如果v-model携带lazy修饰符，那么就自动转成change事件  // change和input事件的区别: https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/change_event  // 2.如果不是滑块类型的input 那么就默认是input事件  const event = lazy ? &quot;change&quot; : type === &quot;range&quot; ? RANGE_TOKEN : &quot;input&quot;;  // 拼装执行语句  let valueExpression = &quot;$event.target.value&quot;;  if (trim) &#123;    valueExpression = `$event.target.value.trim()`;  &#125;  if (number) &#123;    valueExpression = `_n($&#123;valueExpression&#125;)`;  &#125;  // 调用genAssignmentCode语句重组  // 如果value有值，实际上调用的是this.$set方法  // if($event.target.composing)return;$set(day, key, $event.target.value)  let code = genAssignmentCode(value, valueExpression);  if (needCompositionGuard) &#123;    // composition事件 即输入法编辑器编辑时 就直接返回空    code = `if($event.target.composing)return;$&#123;code&#125;`;  &#125;  addProp(el, &quot;value&quot;, `($&#123;value&#125;)`);  // 增加监听事件  addHandler(el, event, code, null, true);  // 如果修饰符是trim或number那么应当立即强制更新  if (trim || number) &#123;    addHandler(el, &quot;blur&quot;, &quot;$forceUpdate()&quot;);  &#125;&#125;// src\\\\compiler\\\\helpers.js 塞进对象export function addHandler(  el: ASTElement,  name: string,  value: string,  modifiers: ?ASTModifiers,  important?: boolean,  warn?: ?Function,  range?: Range,  dynamic?: boolean) &#123;  modifiers = modifiers || emptyObject;  let events;  if (modifiers.native) &#123;    delete modifiers.native;    events = el.nativeEvents || (el.nativeEvents = &#123;&#125;);  &#125; else &#123;    events = el.events || (el.events = &#123;&#125;);  &#125;  // 普通input状态下 返回了&#123; value: value.trim()&#125;  const newHandler: any = rangeSetItem(&#123; value: value.trim(), dynamic &#125;, range);  if (modifiers !== emptyObject) &#123;    newHandler.modifiers = modifiers;  &#125;  // 对象塞入当前监听事件  const handlers = events[name];  if (Array.isArray(handlers)) &#123;    important ? handlers.unshift(newHandler) : handlers.push(newHandler);  &#125; else if (handlers) &#123;    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];  &#125; else &#123;    events[name] = newHandler;  &#125;  el.plain = false;&#125;// src/platforms/web/runtime/modules/events.js 生成vnode后增加事件监听function add(  name: string,  handler: Function,  capture: boolean,  passive: boolean) &#123;  if (useMicrotaskFix) &#123;    const attachedTimestamp = currentFlushTimestamp;    const original = handler;    handler = original._wrapper = function (e) &#123;      if (        e.target === e.currentTarget ||        e.timeStamp &gt;= attachedTimestamp ||        e.timeStamp &lt;= 0 ||        e.target.ownerDocument !== document      ) &#123;        return original.apply(this, arguments);      &#125;    &#125;;  &#125;  // 增加事件监听  target.addEventListener(    name,    handler,    supportsPassive ? &#123; capture, passive &#125; : capture  );&#125;\n\n由上面结合源码可知，在 compiler 编译模板之后生成 ast 语法，生成 ast 语法后会对当前 ast 调用 generate 方法进行一次格式化生成 render 函数，在 patch 阶段调用 updateDOMListeners 挂载当前监听方法，下面是我总结出来的事件编译挂载的流程图\n\n再来看看如何数据的更新监听要想实现数据监听，实时变化。vue2.6 中的策略是这样的，通过 Observer 使用 Object.defineProperty 遍历劫持 data 对象的所有属性，为每个属性生成一个 Dep 消息订阅器，并且在后续挂载中生成一个 Watcher 观察者实例，当第一次调用 render 函数解析模板时，会扫描到模板里面绑定的每个属性，从而触发当前属性的 getter，把当前 Watcher 加入到每个对象的 Dep 的 sub 列表里面，当属性更新之后会就会调用当前属性的 Dep，调用其 sub 里面每个 watcher 的 update 函数来实现更新\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202// 实现依赖收集器// src/core/observer/dep.jslet uid = 0;function remove(list, item) &#123;  const index = list.indexOf(item);  list.splice(index, 1);&#125;class Dep &#123;  constructor() &#123;    this.id = uid++;    this.sub = [];  &#125;  // 订阅所有依赖  depend() &#123;    console.log(this);    if (Dep.target) &#123;      console.log(Dep.target);      Dep.target.addDep(this);    &#125;  &#125;  addSub(watcher) &#123;    this.sub.push(watcher);  &#125;  removeSub(watcher) &#123;    remove(this.sub, watcher);  &#125;  notify() &#123;    console.log(this.sub);    this.sub.forEach((watcher) =&gt; watcher.update());  &#125;&#125;Dep.taget = null;const targetStack = [];// 赋值Dep.target主要是为了禁止某些getter依赖项触发到// Dep.target有值时才能触发depend方法function pushTarget(watcher) &#123;  Dep.target = watcher;  targetStack.push(watcher);&#125;function popTarget() &#123;  targetStack.pop();  Dep.target = targetStack[targetStack.length - 1];&#125;// 实现// src/core/observer/index.jsfunction observe(data) &#123;  let ob;  // 如果是对象，就对其进行监听  if (isObject(data)) &#123;    ob = new Observer(data);  &#125;  return ob;&#125;class Observer &#123;  constructor(data) &#123;    // 初始化依赖收集器    const dep = new Dep();    if (Array.isArray(data)) &#123;    &#125; else &#123;      this.walk(data);    &#125;  &#125;  // 监听内部的每一个key  walk(data) &#123;    const keyList = Object.keys(data);    for (let i = 0; i &lt; keyList.length; i++) &#123;      defineReactive(data, keyList[i]);    &#125;  &#125;&#125;function defineReactive(data, key, value) &#123;  const dep = new Dep();  // 没有传value时默认初始化value  if (arguments.length === 2) &#123;    value = data[key];  &#125;  // 遍历子项  let child = observe(data[key]);  // 对内部每个key进行一次代理  Object.defineProperty(data, key, &#123;    enumerable: true, // 可枚举    configurable: false, // 不能再define    get() &#123;      // 依赖收集器和watcher互相绑定      if (Dep.target) &#123;        dep.depend();        if (child) &#123;          child.dep.depend();        &#125;      &#125;      return value;    &#125;,    set(newValue) &#123;      // 新旧值不同的情况下就直接更新当前函数      if (newValue !== value) &#123;        value = newValue;        child = observe(data[key]);        dep.notify();      &#125;    &#125;,  &#125;);&#125;class Watcher &#123;  constructor(vm, expOrFn, cb, options) &#123;    this.id = ++id;    this.vm = vm;    this.expOrFn = expOrFn;    this.cb = cb;    this.lazy = options.lazy || false;    this.dirty = options.lazy || false;    // 新旧队列    this.newDepIdList = [];    this.depIdList = [];    this.newDepList = new Set();    this.depList = new Set();    console.log(expOrFn);    this.getter =      typeof this.expOrFn === &quot;function&quot;        ? this.expOrFn        : createExpOrFn(this.vm, this.expOrFn);    console.log(this.getter);    this.value = this.lazy ? &quot;&quot; : this.get();  &#125;  addDep(dep) &#123;    // 收集最新的依赖    if (!this.newDepIdList.includes(dep.id)) &#123;      this.newDepIdList.push(dep.id);      this.newDepList.add(dep);      // 如果队列里面没有      if (!this.depIdList.includes(dep.id)) &#123;        dep.addSub(this);      &#125;    &#125;    console.log(dep);  &#125;  // 单纯获取最新的值  get() &#123;    let value;    try &#123;      pushTarget(this);      value = this.getter.call(this.vm);    &#125; catch (e) &#123;    &#125; finally &#123;      this.cleanDepQueue();      popTarget();      console.log(&quot;清除了&quot;, value, this.getter);    &#125;    return value;  &#125;  // 更新  update() &#123;    if (this.lazy) &#123;      this.dirty = true;    &#125; else &#123;      queueWatcher(this);    &#125;  &#125;  run() &#123;    const value = this.get();    if (value !== this.value) &#123;      const oldValue = this.value;      this.cb.call(this.vm, value, oldValue);      this.value = value;    &#125;  &#125;  cleanDepQueue() &#123;    // 收集了新的依赖 如果新的依赖里面没有旧的 那就从旧的依赖里面去掉    // 试想一下 页面的绑定了一个值,并且设置了一个v-if指令，在下一次渲染之后，    // v-if=\\&quot;false\\&quot;不渲染了 但是上一个的依赖却已经被追踪了,这样就    // 会追踪额外的依赖项了，所以必须要清除    for (const dep of this.depList) &#123;      if (!this.newDepList.has(dep)) &#123;        dep.removeSub(this);      &#125;    &#125;    // 新的赋值给旧的  清空新依赖列表 新旧对比    let current = this.depList;    this.depList = this.newDepList;    this.newDepList = current;    this.newDepList.clear();    current = this.depIdList;    this.depIdList = this.newDepIdList;    this.newDepIdList = current;    this.newDepIdList.length = 0;  &#125;&#125;\n\n如果看不太懂的话可以参考我自己写的这一份链接 new Vue 双向绑定示例\n流程图展示下面是我自己绘制的流程图，可以通过这张图的调用顺序更简明地了解更新逻辑\n\n额外的一些注意点当前实例并没有关注到一些性能上的优化点，一个一个地说明会导致篇幅太长，相关的性能处理在上面的 github 示例链接里面，各位小伙伴有兴趣的话可以点击一下查看，帮我点个 star。\n另外可以看看我的其他文章，有一些内容会和当前内容有辅助功能，涉及到了优化相关。\n\nVue2.6 源码解析之数据更新队列和 nextTick 方法解析\nVue2.6 源码解析之 diff 算法更新过程及其相关问题\n\n","slug":"Vue.2.6源码分析之事件挂载和双向绑定原理2021-12-06","date":"2021-12-05T16:00:00.000Z","categories_index":"Vue,总结,Vue源码","tags_index":"Vue","author_index":"谢小谢"},{"id":"a4e456e8c96d4967cd68b187c93c51dc","title":"Nuxt.js线上部署","content":"前段时间自己用 Next.js 的项目部署上线了，记录下 Next.js 的部署方式\nNext.js 项目模块建议使用自带的 dynamic 动态导入模块开始部署\n删除 node_modules 文件夹(文件过大，等在服务器重新下载比较合适)\nLinux 下使用 scp 命令传输到服务器&#x2F;window 下使用 xftp 工具直接拖\n\n\n\n\n\n\n\n\nscp -r 本地文件夹地址 服务器用户名@服务器 ip:远程目录地址\n\n远程目录下 npm install 安装依赖 修改 package.json 的 npm start 命令为 &gt; NODE_ENV&#x3D;production node server.js\nnpm run build\npm2 启动\n\n\n\n\n\n\n\n\npm2 start npm –name &quot;your_server_name&quot; – run start\n\n\n","slug":"Next.js线上部署2021-12-04","date":"2021-12-03T16:00:00.000Z","categories_index":"","tags_index":"Vue,服务端渲染","author_index":"谢小谢"},{"id":"4d925ea8030231a2d81ae35ccafce2c7","title":"Vue2.6源码解析之数据更新队列和nextTick方法解析","content":"用了这么久的 Vue，我们都可以从官网上面知道，Vue 在更新 DOM 时是异步执行的,Vue 将开启一个队列，缓冲在同一事件循环中发生的所有数据变更,如果同一个 watcher 被多次触发，只会被推入到队列中一次，注: 首先要了解下 js 的事件循环和异步任务队列问题\n那么内部究竟是如何实现的呢，我们对源代码进行细纠，下面会省略一些不相关的代码。\n提供第一个 template 范例如果看了我的事件循环的文章，那么就可以知道任务队列中的异步任务分 task 任务和 microTask 微任务，每一次执行 task 的时候都会执行清空该 task 下的同级 microtask，理解这个原理对源码理解有巨大作用\n123456789101112131415161718192021222324252627282930313233343536373839404142&lt;div id=&quot;app&quot; @click=&quot;setData&quot;&gt;  &lt;span&gt;&#123;&#123; les &#125;&#125;/ &#123;&#123;time&#125;&#125;&lt;/span&gt;  &lt;uptime-day :day=&quot;day&quot; :les=&quot;les&quot; :time=&quot;time&quot; /&gt;&lt;/div&gt;&lt;script&gt;  const uptimeDay = &#123;    props: [&quot;time&quot;, &quot;les&quot;],    data() &#123;      return &#123;        isTrue: true,      &#125;;    &#125;,    methods: &#123;      handleClick() &#123;        this.isTrue = false;        this.$nextTick(() =&gt; &#123;          console.log(this.uptimeDay.innerText);        &#125;);      &#125;,    &#125;,    template: `&lt;div @click=&quot;handleClick&quot; ref=&quot;uptimeDay&quot;&gt;&#123;&#123; les &#125;&#125; &#123;&#123; time &#125;&#125;&lt;/div&gt;`,  &#125;;  var app = new Vue(&#123;    el: &quot;#app&quot;,    components: &#123;      uptimeDay,    &#125;,    data() &#123;      return &#123;        les: &quot;谢小谢&quot;,        time: &quot;now&quot;,      &#125;;    &#125;,    methods: &#123;      setData() &#123;        this.les = &quot;谢谢谢&quot;;        this.time = &quot;before&quot;;      &#125;,    &#125;,  &#125;);&lt;/script&gt;\n\n这里进行一步点击操作 调用 setData 函数\n初始渲染逻辑粗略解读\n\n\n\n\n\n\n\n\n看过源码的大概都知道，new Vue 之后的最后一步是调用 mountComponent 方法生成 Watcher 订阅者，watcher 传入了一个 updateComponent 函数（内部包含\\_update,render 方法）作为 getter,初始化时 Watcher 会调用其 getter 方法，进入内部逻辑调用 render 生成 vnode，调用\\_update 方法对 vnode 进行 patch 操作,具体请看下图。\n\n当前模板在\\_createElement 时，遇到子组件，判断是不是原生标签之后，会调用 Vue.extend 方法重头调用一次 Vue.prorotype.init 方法，所以当前会生成 2 个 Watcher。\n着重看一下 queueWatcher 执行过程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// src/core/observer/scheduler.js// 最大更新数量export const MAX_UPDATE_COUNT = 100const queue: Array&lt;Watcher&gt; = []const activatedChildren: Array&lt;Component&gt; = []let has: &#123; [key: number]: ?true &#125; = &#123;&#125;let circular: &#123; [key: number]: number &#125; = &#123;&#125;let waiting = falselet flushing = falselet index = 0// 重置队列和刷新状态function resetSchedulerState() &#123;  index = queue.length = activatedChildren.length = 0  has = &#123;&#125;  waiting = flushing = false&#125;export let currentFlushTimestamp = 0let getNow: () =&gt; number = Date.nowfunction flushSchedulerQueue() &#123;  // 设置当前的时间戳  currentFlushTimestamp = getNow()  flushing = true  let watcher, id  // 所有watcher根据id升序排列  // 疑问: 点解要排序？  // 回答: 1. 组件是从父级更新到子级，组件的渲染顺序是优于父级的，如果某个组件在父组件的观察程序运行期间被销毁，则可以跳过  queue.sort((a, b) =&gt; a.id - b.id)  // queue长度随时变化  for (index = 0; index &lt; queue.length; index++) &#123;    watcher = queue[index]    if (watcher.before) &#123;      watcher.before()    &#125;    id = watcher.id    has[id] = null    watcher.run()  &#125;  // 保留上次缓存过和更新后的状态实例 为下次触发生命周期做准备  const activatedQueue = activatedChildren.slice()  const updatedQueue = queue.slice()  // 清空状态  resetSchedulerState()  // 设置当前组件更activated状态  callActivatedHooks(activatedQueue)  // 设置当前组件为已更新状态  callUpdatedHooks(updatedQueue)&#125;// 触发生命周期function callUpdatedHooks(queue) &#123;  let i = queue.length  while (i--) &#123;    const watcher = queue[i]    const vm = watcher.vm    if (vm._watcher === watcher &amp;&amp; vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;      callHook(vm, &#x27;updated&#x27;)    &#125;  &#125;&#125;export function queueActivatedComponent(vm: Component) &#123;router-view)  vm._inactive = false  activatedChildren.push(vm)&#125;function callActivatedHooks(queue) &#123;  for (let i = 0; i &lt; queue.length; i++) &#123;    queue[i]._inactive = true    activateChildComponent(queue[i], true /* true */)  &#125;&#125;// 推watcher入栈export function queueWatcher(watcher: Watcher) &#123;  const id = watcher.id  if (has[id] == null) &#123;    has[id] = true    // 当前队列没有冲刷的时候    if (!flushing) &#123;      // 把当前watcher加入队列      queue.push(watcher)    &#125; else &#123;      // 已冲刷的和已经通过的就删除掉      let i = queue.length - 1      while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;        i--      &#125;      queue.splice(i + 1, 0, watcher)    &#125;    // 不是在等待中    if (!waiting) &#123;      nextTick(flushSchedulerQueue)    &#125;  &#125;&#125;\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// src/core/util/next-tick.jsexport let isUsingMicroTask = false;const callbacks = [];let pending = false;function flushCallbacks() &#123;  pending = false;  const copies = callbacks.slice(0);  callbacks.length = 0;  for (let i = 0; i &lt; copies.length; i++) &#123;    copies[i]();  &#125;&#125;// timeFunc根据环境兼容处理使用任务或者微任务let timerFunc;if (typeof Promise !== &quot;undefined&quot; &amp;&amp; isNative(Promise)) &#123;  const p = Promise.resolve();  timerFunc = () =&gt; &#123;    p.then(flushCallbacks);    if (isIOS) setTimeout(noop);  &#125;;  isUsingMicroTask = true;&#125; else if (  !isIE &amp;&amp;  typeof MutationObserver !== &quot;undefined&quot; &amp;&amp;  (isNative(MutationObserver) ||    MutationObserver.toString() === &quot;[object MutationObserverConstructor]&quot;)) &#123;  let counter = 1;  const observer = new MutationObserver(flushCallbacks);  const textNode = document.createTextNode(String(counter));  observer.observe(textNode, &#123;    characterData: true,  &#125;);  timerFunc = () =&gt; &#123;    counter = (counter + 1) % 2;    textNode.data = String(counter);  &#125;;  isUsingMicroTask = true;&#125; else if (typeof setImmediate !== &quot;undefined&quot; &amp;&amp; isNative(setImmediate)) &#123;  timerFunc = () =&gt; &#123;    setImmediate(flushCallbacks);  &#125;;&#125; else &#123;  // Fallback to setTimeout.  timerFunc = () =&gt; &#123;    setTimeout(flushCallbacks, 0);  &#125;;&#125;// 主处理函数export function nextTick(cb?: Function, ctx?: Object) &#123;  let _resolve;  // 入栈  callbacks.push(() =&gt; &#123;    if (cb) &#123;      try &#123;        cb.call(ctx);      &#125; catch (e) &#123;        handleError(e, ctx, &quot;nextTick&quot;);      &#125;    &#125; else if (_resolve) &#123;      _resolve(ctx);    &#125;  &#125;);  // 非等待情况下  if (!pending) &#123;    pending = true;    timerFunc();  &#125;&#125;\n\ntemplate 范例解读\n根据入口遍历，根组件和子组件会生成两个 watcher 实例，从父到子我们成为 watcher1， watcher2\n由上面的 template 可知，根组件#app 和子组件 uptimeDay 都绑定了事件，点击 uptimeDay 组件时，子组件 handleClick 方法已经进入整体 task 队列，内部 isTrue 为 true 时 setter 触发，进入 queueWatcher(watcher2),has[id]为 false,flushing 为 false 进入推入 queue 队列，调用 nextTick(flushSchedulerQueue: 简称该方法为 Fn1) ，nextTick 入栈后 callBack 推入 f1，默认 pending 为 false，调用 timeFunc，此时该函数进入 handleClick 这个 task 下的微任务队列里面，pending 变 true。\n随后，下方又调用了 this.$nextTick(() &#x3D;&gt; { console.log(this.$refs.ss.innerText); 简称该方法为 Fn2 }), Fn2 进入 nextTick 之后发现 pending &#x3D; true，所以被合并进入 callBacks 更新，pending &#x3D; false 子组件 patch 更新完成 queueWatcher。 初始化 重点: 此时，props 传进来的值并没有更新影响到 dom，打印出来的对象是有滞后性的，必须打印普通类型的值才能正确显示\n接着，事件冒泡到父级，setData 触发进入另外一个 task 队列，接着更改了 les,time 的值。触发 les 的 setter 更新进入 queueWatcher(watcher1)。首先 has[id]为 null, flushing 为 false, watcher1 被推入 queue 队列调用 nextTick，nextTick 内部 pending 为 false，执行 timeFunc，推入微任务队列挂起。随后 time 的 setter 被触发，后进入 queueWatcher，发现 has[id]为 true，waiting 为 true, 不推入队列。重点: 此时，这里就是上文说的 watcher 被多次触发，只推入队列一次，接着 timeFunc 的微任务开始调用，进入 flushSchedulerQueue 完成更新\n\n结论\n同 watcher 内更新只更新一次，因为多个 data 改变时，第一次的 reRender 就可以拿到当前实例上的最新值了，无需耗费更多计算资源。\n如果外部组件修改，子组件没有绑定当前修改的属性，并且没有应用于 dom，那么也是不会更新到子组件的(这个得看一下 Observe 数据劫持和 patch 的过程才能了解)\nscheduler.js 中有一段代码是很值得玩味的\n\n123456789101112// src/core/observer/scheduler.js// queue长度随时变化for (index = 0; index &lt; queue.length; index++) &#123;  watcher = queue[index];  if (watcher.before) &#123;    watcher.before();  &#125;  id = watcher.id;  has[id] = null;  watcher.run();&#125;\n\n这里算是对上面第 4 步的补充，当根组件的实例更新后，子组件也会更新重新进入 queueWatcher，watcher2 会被推入 queue 队列，此时循环体内的 queue 长度增加, 会一层一层往下调用子组件的 watcher 的 run 方法不断地重新 render 来进行 patch 操作，直到没有子组件为止(为什么？因为 vnode 为组件类型时没有 children，无法 patch，必须得重新 render 解析组件)\n","slug":"Vue2.6源码解析之数据更新队列和nextTick方法解析2021-11-24","date":"2021-11-23T16:00:00.000Z","categories_index":"Vue,总结,Vue源码","tags_index":"Vue","author_index":"谢小谢"},{"id":"b2c8fccb8cb0e13a9e85ff1f7f24091a","title":"uni-app实现京东canvas拍照识图功能","content":"\n\n\n\n\n\n\n\n\n最近公司出了一个新的功能模块(如下图)，大提上可以描述为实现拍照完上传图片，拖动四方框拍照完成上传功能，大体样子如下图。但是我找遍了 dcloud 插件市场，找到的插件都是移动背景图片来实现裁剪的，跟京东的功能是相反的，没办法只能自己来实现这么一个插件。\n\n第一步首先就需要实现一个四方框的功能了。从上图可知，四方框有一下几个特点\n\n四个角粘连外框，随着框的大小和移动范围紧缚移动\n四方框可随意四个方向拖动\n方框外区域阴影不影响方框内\n\n那么我们根据这个特性来实现下这个功能，对于 css 规范的话使用 bem 规范\n123&lt;div class=&quot;clip__content&quot;&gt;  &lt;div v-for=&quot;(item, index) in 4&quot; :key=&quot;index&quot; class=&quot;clip__edge&quot;&gt;&lt;/div&gt;&lt;/div&gt;\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071$edge-border-width: 6rpx;.clip &#123;  &amp;__content &#123;    position: fixed;    width: 400rpx;    height: 400rpx;    left: 0;    top: 0;    border: 1px solid red;    z-index: 4;    overflow: hidden;    box-shadow: rgba(0, 0, 0, 0.5) 0 0 0 200vh;  &#125;  &amp;__edge &#123;    position: absolute;    width: 34rpx;    height: 34rpx;    border: 10rpx solid red;    pointer-events: auto;    z-index: 2;    &amp;::before &#123;      content: &quot;&quot;;      position: absolute;      z-index: 2;      width: 40rpx;      height: 40rpx;      background-color: transparent;    &#125;    &amp;:nth-child(1) &#123;      left: $edge-border-width;      top: $edge-border-width;      border-bottom-width: 0 !important;      border-right-width: 0 !important;      &amp;:before &#123;        top: -50%;        left: -50%;      &#125;    &#125;    &amp;:nth-child(2) &#123;      right: $edge-border-width;      top: $edge-border-width;      border-bottom-width: 0 !important;      border-left-width: 0 !important;      &amp;:before &#123;        top: -50%;        left: 50%;      &#125;    &#125;    &amp;:nth-child(3) &#123;      left: $edge-border-width;      bottom: $edge-border-width;      border-top-width: 0 !important;      border-right-width: 0 !important;      &amp;:before &#123;        bottom: -50%;        left: -50%;      &#125;    &#125;    &amp;:nth-child(4) &#123;      right: $edge-border-width;      bottom: $edge-border-width;      border-top-width: 0 !important;      border-left-width: 0 !important;      &amp;:before &#123;        bottom: -50%;        left: 50%;      &#125;    &#125;  &#125;\n\n根据上面的 html 和 css 出来的样式大概如下图 外部的阴影效果我们用： box-shadow: rgba(0, 0, 0, 0.5) 0 0 0 200vh 来达成\n\n第二步第二步的话就要实现移动功能了，这里是一个比较考验耐心的地方，因为涉及到多个方向的变化，需要不断地进行调试，在此之前需要先分析下四个角变化的特性，下面先看 4 个角的移动特性(以 H5 思维)\n\n第一个角的移动会改变方框的 left，top，width，right4 个值\n第二个角的移动会改变方框的 top，with，height3 个值\n第三个角的移动会改变方框的 left, width，height3 个值\n第四个角的移动会改变方框的 width，height2 个值\n四个角的移动都不能小于 4 个角的宽高，四个角的移动都不能超过屏幕，相应的逻辑需要做一下限制\n\n\n首先需要获取下屏幕宽度，区域高度(因为头部可能会有导航栏目占位，所以不拿屏幕高度)，四方框初始宽高,\n123456789101112131415161718192021uni.getSystemInfo(&#123;  success: (res) =&gt; &#123;    console.log(res);    this.systemInfo = res;  &#125;,&#125;);uni  .createSelectorQuery()  .select(&quot;.clip__content&quot;)  .fields(&#123; size: true &#125;, (data) =&gt; &#123;    this.width = data.width;    this.height = data.height;  &#125;)  .exec();uni  .createSelectorQuery()  .select(&quot;.clip&quot;)  .fields(&#123; size: true &#125;, (data) =&gt; &#123;    this.screenHeight = data.height;  &#125;)  .exec();\n\n后续的话就可以进行四个角拖拽了，这里用到了 touchStart 和 touchMove,动态地为方框绑定样式\n1234567&lt;div  v-for=&quot;(item, index) in 4&quot;  class=&quot;clip__edge&quot;  @touchstart.stop.prevent=&quot;edgeTouchStart&quot;  @touchmove.stop.prevent=&quot;e =&gt; edgeTouchMove(e, index)&quot;  @touchend.stop.prevent=&quot;edgeTouchEnd&quot;&gt;&lt;/div&gt;\n\n接下来开始写逻辑\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687edgeTouchStart(e) &#123;  // 记录坐标xy初始位置  this.clientX = e.changedTouches[0].clientX;  this.clientY = e.changedTouches[0].clientY;&#125;,edgeTouchMove(e, index) &#123;  const currX = e.changedTouches[0].clientX;  const currY = e.changedTouches[0].clientY;  // 记录坐标差  const moveX = currX - this.clientX;  const moveY = currY - this.clientY;  // 更新坐标位置  this.clientX = currX;  this.clientY = currY;  const &#123; width, height, left, top, screenHeight &#125; = this;  const &#123; screenWidth &#125; = this.systemInfo;  // 初始化最大宽高  let maxWidth = 0,    maxHeight = 0,    maxTop = top + moveY &lt; 0 ? 0 : top + moveY,    maxLeft = left + moveX &lt; 0 ? 0 : left + moveX;  // 四个角的宽高限制  if (index % 2 === 0) &#123;    maxWidth = width - moveX &gt; screenWidth ? screenWidth : width - moveX;  &#125; else &#123;    maxWidth = width + moveX &gt; screenWidth ? screenWidth : width + moveX;  &#125;  if (index &lt; 2) &#123;    maxHeight =      height - moveY &gt; screenHeight ? screenHeight : height - moveY;  &#125; else &#123;    maxHeight =      height + moveY &gt; screenHeight ? screenHeight : height + moveY;  &#125;  // 四个角的规则计算逻辑 四边方框暂定40 更详细的要用.createSelectorQuery()去拿  if (index === 0) &#123;    if (width - moveX &lt;= 40 || height - moveY &lt;= 40) return;    console.log(maxLeft);    this.clipStyle = &#123;      width: maxWidth,      height: maxHeight,      left: maxLeft,      top: maxTop,    &#125;;    this.width = maxWidth;    this.height = maxHeight;    this.top = maxTop;    this.left = maxLeft;    // 右上角  &#125; else if (index === 1) &#123;    if (width + moveX &lt;= 40 || height - moveY &lt;= 40) return;    this.clipStyle = &#123;      width: maxWidth,      height: maxHeight,      left,      top: maxTop,    &#125;;    this.width = maxWidth;    this.height = maxHeight;    this.top = maxTop;  &#125; else if (index === 2) &#123;    if (width - moveX &lt;= 40 || height + moveY &lt;= 40) return;    this.clipStyle = &#123;      width: maxWidth,      height: maxHeight,      left: maxLeft,      top,    &#125;;    this.width = maxWidth;    this.height = maxHeight;    this.left = maxLeft;  &#125; else if (index === 3) &#123;    if (width + moveX &lt;= 40 || height + moveY &lt;= 40) return;    this.clipStyle = &#123;      width: maxWidth,      height: maxHeight,      left,      top,    &#125;;    this.width = maxWidth;    this.height = maxHeight;  &#125;&#125;\n\n效果如下图\n\n第三步四个角拖拽逻辑完善之后，下一步目标就是做四方框的拖拽，这边需要对四方框的拖拽做一次限制\n12345678&lt;div  class=&quot;clip__content&quot;  :style=&quot;style&quot;  @touchstart.stop.prevent=&quot;clipTouchStart&quot;  @touchmove.stop.prevent=&quot;clipTouchMove&quot;&gt;  ...&lt;/div&gt;\n\n12345678910111213141516171819202122232425262728293031323334clipTouchStart(e) &#123;  this.touchX = e.changedTouches[0].pageX;  this.touchY = e.changedTouches[0].pageY;&#125;,clipTouchMove(e) &#123;  const &#123; screenWidth &#125; = this.systemInfo;  const currX = e.changedTouches[0].pageX;  const currY = e.changedTouches[0].pageY;  const moveX = currX - this.touchX;  const moveY = currY - this.touchY;  this.touchX = currX;  this.touchY = currY;  // 边框限制逻辑  if (this.left + moveX &lt; 0) &#123;    this.left = 0;  &#125; else if (this.left + moveX &gt; screenWidth - this.width) &#123;    this.left = screenWidth - this.width;  &#125; else &#123;    this.left = this.left + moveX;  &#125;  if (this.top + moveY &lt; 0) &#123;    this.top = 0;  &#125; else if (this.top + moveY &gt; this.screenHeight - this.height) &#123;    this.top = this.screenHeight - this.height;  &#125; else &#123;    this.top = this.top + moveY;  &#125;  this.clipStyle = &#123;    ...this.clipStyle,    left: this.left,    top: this.top,  &#125;;&#125;,\n\n效果如下图：\n\n第四步就是做我们的截图了，这里用到了 canvas1234&lt;div class=&quot;clip__content&quot;&gt;  ...  &lt;canvas class=&quot;clip-canvas&quot; canvas-id=&quot;clip-canvas&quot;&gt;&lt;/canvas&gt;&lt;/div&gt;\n\n\n\n\n\n\n\n\n\n\n逻辑的话目前这个例子是使用了网络的 url 图片 所以要进行 download，如果是不用网络图片，那么这一句可以删除换成其他的获取图片 api\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364initCanvas() &#123;  uni.showLoading(&#123;    title: &quot;加载中...&quot;,  &#125;);  uni    .createSelectorQuery()    .select(&quot;.clip__content&quot;)    .fields(      &#123;        size: true,        scrollOffset: true,        rect: true,        context: true,        computedStyle: [&quot;transform&quot;, &quot;translateX&quot;],        scrollOffset: true,      &#125;,      (data) =&gt; &#123;        uni.downloadFile(&#123;          url: this.imageUrl,          success: (res) =&gt; &#123;            this.canvasInstance = uni.createCanvasContext(              &quot;clip-canvas&quot;,              this            );            this.canvasInstance.drawImage(              res.tempFilePath,              -data.left,              -data.top,              this.systemInfo.screenWidth,              this.screenHeight,              0,              0            );            this.canvasInstance.draw(              false,              (() =&gt; &#123;                setTimeout(() =&gt; &#123;                  uni.canvasToTempFilePath(                    &#123;                      x: 0,                      y: 0,                      width: data.width,                      height: data.height,                      dWidth: data.width,                      dHeight: data.height,                      fileType: &quot;jpg&quot;,                      canvasId: &quot;clip-canvas&quot;,                      success: (data) =&gt; &#123;                        uni.hideLoading();                        this.url = data.tempFilePath;                        // this.canvasInstance.save();                      &#125;,                    &#125;,                    this                  );                &#125;, 500);              &#125;)()            );          &#125;,        &#125;);      &#125;    )    .exec();&#125;,\n\n效果如图所示：\n\n最后，我们的插件就正式完成了\n具体代码可以看这个仓库链接，有什么问题可以在下方留言\n","slug":"uni-app实现京东canvas拍照识图功能","date":"2021-11-13T16:00:00.000Z","categories_index":"uni-app","tags_index":"uni-app,canvas,微信小程序","author_index":"谢小谢"},{"id":"c583867df2db339c8477f09807897308","title":"懂表帝项目阶段性总结","content":"uni-app 懂表帝小程序 v2.1.0 已经发布上线，现在针对里面遇到的一些小问题做一下阶段性的复盘\n安卓 P30 下点击 input 框聚焦后点击其他 dom，input 框的 blur 周期没有触发导致底部栏悬空不下坠，大概样子如下图\n12345678910111213141516171819202122232425262728// sendMessage.vue&lt;wb-safe-footer  :customStyle=&quot;&#123; bottom: bottom + &#x27;px&#x27;, zIndex: 999 &#125;&quot;&gt;  &lt;div class=&quot;send-message&quot;&gt;    &lt;input      ...      ref=&quot;input&quot;      v-model=&quot;message&quot;      confirm-type=&quot;send&quot;      @focus=&quot;handleFoucs&quot;      @blur=&quot;handleBlur&quot;    /&gt;  &lt;/div&gt;&lt;/wb-safe-footer&gt;&lt;script&gt;  // 聚焦  handleFocus(&#123; mp &#125;) &#123;    this.bottom = mp.detail.height    this.$emit(&#x27;focus&#x27;)  &#125;,  // 失焦  handleBlur() &#123;    this.$emit(&#x27;blur&#x27;)    this.bottom = 0  &#125;&lt;/script&gt;\n\n大概代码如上,通过 blur 改变 bottom 值，但是 blur 不触发 只好在外部函数内直接调用 handleBlur 方法\n123456789101112131415161718// shortVideo.vue&lt;comments  ...  @close=&quot;closeCommentsPopup&quot;/&gt;&lt;send-message  ...  ref=&quot;sendMessage&quot;/&gt;&lt;script&gt;// 关闭弹框closeCommentsPopup() &#123;  // 解决华为P30下键盘向下没触发input框的blur钩子问题  this.$refs.sendMessage.handleBlur()&#125;&lt;/script&gt;\n\n华为 P30 和小米 8 下 chooseImage 导致空栏目问题\n解决办法：用 showModel 模拟出两个选择方式的状态\n","slug":"懂表帝项目阶段性总结","date":"2021-09-02T16:00:00.000Z","categories_index":"uni-app","tags_index":"uni-app,懂表帝","author_index":"谢小谢"},{"id":"d02145c722134b6141381c5add87923b","title":"服务器之正向代理和反向代理","content":"最近公司商家入驻准备上线，和运维在服务器代理这边折腾了不少时间，现在重新归纳一下正向代理和反向代理的相关概念和区别\n正向代理简述：正向代理服务器作接受来自客户端的请求，请求源服务器，把原服务器返回的内容响应给客户端\n注意：(此时源服务器并不知道客户端是谁)\n\n正向代理的应用&#x2F;使用原因：\n\n网址被墙，就可以在外网架设一个服务器作为中间服务器进行代理转发\n隐藏自身的浏览行为\n\n反向代理简述: 同正向代理一样，但是客户端并不知道实际访问的源服务器是谁，因为源服务器实际上可能会有多个，所以实际上像访问谷歌这种网页，都是要经过一层反向代理的服务器\n\n反向代理的应用&#x2F;使用原因：\n\n基于安全原因，不想直接暴露源服务器地址，就可以使用一个反向代理服务器，连接内外网，将反向代理服务器层作为类防火墙功能，进行安全校验。\n服务器负载均衡，访问一个资源时，根据源服务器的具体工作情况，分发到合适的服务器之中)\n\n反向代理和正向代理的区别\n\n\n\n\n\n\n\n\n正向代理服务器只对客户端负责，即隐藏用户\n\n\n\n\n\n\n\n\n\n反向代理服务器只对自己所代理的服务器负责，即隐藏源服务器\nVue 框架的开发时反向代理服务器路径设置及其区别12345678910// 请求地址 /api/blog/tags&#x27;/api&#x27; : &#123;target: &#x27;http://127.0.0.1:7001&#x27;,  pathRewrite: &#123;    &#x27;^/api&#x27;: &#x27;/blog&#x27; // 重写了url 相当于请求 http://127.0.0.1:7001/blog/blog/tags    &#x27;^/api&#x27;: &#x27;&#x27; // 重写了url 相当于请求 http://127.0.0.1:7001/blog/tags    &#x27;&#x27;: &#x27;&#x27; // 重写了url 相当于请求 http://127.0.0.1:7001/api/blog/tags  &#125;&#125;\n","slug":"服务器之正向代理和反向代理","date":"2021-07-27T16:00:00.000Z","categories_index":"总结","tags_index":"http","author_index":"谢小谢"},{"id":"e9c62f00849307d6c77e106ff0b62f1c","title":"Http权威指南阅读总结","content":"HTTP 基础分层架构\n应用层: HTTP，DNS，FTP\n传输层: TCP，UDP\n网络层: IP\n数据链路: 控制操作系统、硬件的设备驱 动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等 物理可见部分（还包括连接器等一切传输媒介）。\n\n请求过程每个层的作用HTTP 生成请求报文，TCP 按顺序将报文切割生成多个顺序序号的报文段，把报文段可靠地传输给对方，IP 主要搜索对方的地址，一边中转一遍传送(因为每个地址在同一局域网的情况是很少的，所以可能需要多次中转，使用 ARP 协议解析地址)\nHTTP&#x2F;1.1 特点\nconnection: keep-alive 持久链接(减少 tcp 建立和资源获取的时间，注: http&#x2F;1.0 并未标准化)\n管线化(不用等待响应就能发送下一次请求)\n\nHTTP&#x2F;1.1 的客户身份认证方式\nBASIC 认证（基本认证）\nDIGEST 认证（摘要认证）\nSSL 客户端认证\nFormBase 认证（基于表单认证）\n\nHTTP&#x2F;2.0 新增\n多路复用流（通过单一的 TCP 连接，可以无限制处理多个 HTTP 请求。所有请求 的处理都在一条 TCP 连接上完成，因此 TCP 的处理效率得到提高）\n赋予请求优先级 （SPDY 不仅可以无限制地并发处理请求，还可以给请求逐个分配优先 级顺序。这样主要是为了在发送多个请求时，解决因带宽低而导致响 应变慢的问题。）\n压缩 HTTP 首部\n服务端推送\n\nHTTP 报文详解\n内容压缩 gzip（GNU zip），compress（UNIX 系统的标准压缩），deflateidentity（不进行编码）（zlib）\n\nHTTP 状态码\n1XX Informational（信息性状态码） 接收的请求正在处理\n2XX Success（成功状态码） 请求正常处理完毕\n3XX Redirection（重定向状态码） 需要进行附加操作以完成请求\n4XX Client Error（客户端错误状态码） 服务器无法处理请求\n5XX Server Error（服务器错误状态码） 服务器处理请求出错\n\n其中 301(永久重定向)，302(临时重定向) 301 会导致 url 劫持，搜索引擎搜索到的自己发布的内容是在别人的网站上\n400(传参错误)，401(鉴权失效，未登录), 403(无权限)，404(没有找到该 URL)\n与 HTTP 协作的 web 服务器（代理、网关、隧 道）\n网关和代理基本功能差不多，但是当 HTTP 请求的对象不支持 HTTP 协议时，利用网关可以由 HTTP 请求转化为其他协议通信，利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信 线路上加密以确保连接的安全。比如，网关可以连接数据库，使用 SQL 语句查询数据。另外，在 Web 购物网站上进行信用卡结算时， 网关可以和信用卡结算系统联动。\n隧道可按要求建立起一条与其他服务器的通信线路，届时使用 SSL 等 加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的 通信。\n\nHTTP 协议缺点\n通信使用明文（不加密），内容可能会被窃听(TSL,SSL 加密解决)\n不验证通信方的身份，因此有可能遭遇伪装(SSL 加密提供证书)\n无法验证报文的完整性,内容有可能被篡改，也就是 DOS 中间人攻击(MD5 和 SHA-1 等散列值校验)\n\nHTTP 加密\n采用对称加密和非对称加密(公开密钥加密方式获取公钥，保证安全性，用共享密钥进行解密，提升速度， 共享密闭比公开密钥的速度快)\nHTTPS 采用混合加密机制 HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密 机制。若密钥能够实现安全交换，那么有可能会考虑仅使用公开 密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其处 理速度要慢。 所以应充分利用两者各自的优势，将多种方法组合起来用于通 信。在交换密钥环节使用公开密钥加密方式，之后的建立通信交 换报文阶段则使用共享密钥加密方式。\n\n如何判断公开密钥的正确性？ 使用 CA 证书\n","slug":"Http权威指南阅读总结","date":"2021-07-04T16:00:00.000Z","categories_index":"http","tags_index":"http","author_index":"谢小谢"},{"id":"fb926e417168eb419b385ba9a5f127a1","title":"懂表帝微信小程序授权流程总览","content":"之前微信小程序官方使用了新的 wx.getUserProfile 替换了旧的 wx.getUserInfo，因为做了很多小程序的登录授权，一段时间不接触之后又会忘记。在此先记录下来新版本的授权流程\n明确某些值的概念\ncode：用户登录标识（有效期五分钟），由 wx.Login 返回\nencryptedData：包括敏感数据在内的完整用户信息的加密数据，wx.getUserProfile 或  等 api 返回\niv：加密算法的初始向量，wx.getUserProfile 或  等 api 返回\ncloudID：开通云开发的小程序才会返回，可通过云调用直接获取开放数据，wx.getUserProfile 或  等 api 返回\nuserInfo：授权时的用户数据，wx.getUserProfile 返回\nappId：小程序的唯一标识, 注册小程序时自动生成\nunionId：用户的唯一标识, 调用后端的登录接口后返回\nopenId：用户在微信开放平台帐号下的唯一标识, 调用后端的登录接口后返回\n\n懂表帝微信登录结构图整理\n下面这张是微信官方的授权流程图，参考使用\n","slug":"懂表帝微信小程序授权流程总览","date":"2021-07-02T16:00:00.000Z","categories_index":"业务流程","tags_index":"小程序","author_index":"谢小谢"},{"id":"ed256b7d0dc1c9858a4d40687aeaf04d","title":"Dcloud的Canvas插件二次改写为Vue模板","content":"由于公司用的海报图插件都是使用的canvas_drawer插件来绘制海报图，由于是 18 年的插件，且只支持微信小程序原生语法。如果有其他客户端小程序的要求下是无法兼容的，对此我将他改造成 vue 组件形式来适配 uni-app 的多客户端需求\n改造要点\n部分 setData 语法存在异步情况，可能会导致逻辑问题\n旧文件里面使用的 promise.then 语法太过于冗杂，更换成 async await 语法兼容\n旧的 triggerEvent 更换成 emit\n字节小程序同时进行 2 次渲染会导致渲染重叠，传入的 id 实例不能重复\n\n下面看主要改造后的代码\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337&lt;template&gt;  &lt;view&gt;    &lt;canvas      :canvas-id=&quot;name&quot;      :style=&quot;&#123; width: width + &#x27;px&#x27;, height: height + &#x27;px&#x27; &#125;&quot;      class=&quot;board&quot;      v-if=&quot;showCanvas&quot;    &gt;&lt;/canvas&gt;  &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  props: &#123;    painting: &#123;      type: Object,    &#125;,    name: &#123;      type: String,    &#125;,  &#125;,  data() &#123;    return &#123;      showCanvas: false,      width: 100,      height: 100,      tempFileList: [],      isPainting: false,      ctx: null,      cache: Array(),    &#125;;  &#125;,  watch: &#123;    painting(newVal, oldVal) &#123;      if (!this.isPainting) &#123;        if (JSON.stringify(newVal) !== JSON.stringify(oldVal)) &#123;          if (newVal &amp;&amp; newVal.width &amp;&amp; newVal.height) &#123;            this.showCanvas = true;            this.isPainting = true;            this.readyPigment();          &#125;        &#125; else &#123;          if (newVal &amp;&amp; newVal.mode !== &quot;same&quot;) &#123;            // this.triggerEvent(&#x27;getImage&#x27;, &#123;errMsg: &#x27;canvasdrawer:samme params&#x27;&#125;)            this.$emit(&quot;getImage&quot;, &#123; errMsg: &quot;canvasdrawer:samme params&quot; &#125;);          &#125;        &#125;      &#125;    &#125;,  &#125;,  onReady() &#123;    uni.removeStorageSync(&quot;canvasdrawer_pic_cache&quot;);    this.ctx = uni.createCanvasContext(this.name, this);  &#125;,  methods: &#123;    readyPigment() &#123;      const width = this.painting.width;      const height = this.painting.height;      const views = this.painting.views;      this.width = width;      this.height = height;      const inter = setInterval(() =&gt; &#123;        if (this.ctx) &#123;          clearInterval(inter);          // this.ctx.clearActions()          this.ctx.save();          this.getImagesInfo(views);        &#125;      &#125;, 100);    &#125;,    async getImagesInfo(views) &#123;      const imageList = [];      for (let i = 0; i &lt; views.length; i++) &#123;        if (views[i].type === &quot;image&quot;) &#123;          imageList.push(await this.getImageInfo(views[i].url));        &#125;      &#125;      this.tempFileList = imageList;      this.startPainting();    &#125;,    startPainting() &#123;      const tempFileList = this.tempFileList;      const views = this.painting.views;      // const &#123; tempFileList, painting: &#123; views &#125; &#125; = this.$data      for (let i = 0, imageIndex = 0; i &lt; views.length; i++) &#123;        if (views[i].type === &quot;image&quot;) &#123;          this.drawImage(&#123;            ...views[i],            url: tempFileList[imageIndex],          &#125;);          imageIndex++;        &#125; else if (views[i].type === &quot;text&quot;) &#123;          if (!this.ctx.measureText) &#123;            uni.showModal(&#123;              title: &quot;提示&quot;,              content:                &quot;当前版本过低，无法使用 measureText 功能，请升级到最新微信版本后重试。&quot;,            &#125;);            // this.triggerEvent(&#x27;getImage&#x27;, &#123;errMsg: &#x27;canvasdrawer:version too low&#x27;&#125;)            this.$emit(&quot;getImage&quot;, &#123; errMsg: &quot;canvasdrawer:version too low&quot; &#125;);            return;          &#125; else &#123;            this.drawText(views[i]);          &#125;        &#125; else if (views[i].type === &quot;rect&quot;) &#123;          this.drawRect(views[i]);        &#125;      &#125;      this.ctx.draw(false, () =&gt; &#123;        uni.setStorageSync(&quot;canvasdrawer_pic_cache&quot;, this.cache);        const system = uni.getSystemInfoSync().system;        if (/ios/i.test(system)) &#123;          this.saveImageToLocal();        &#125; else &#123;          // 延迟保存图片，解决安卓生成图片错位bug。          setTimeout(() =&gt; &#123;            this.saveImageToLocal();          &#125;, 800);        &#125;      &#125;);    &#125;,    drawImage(params) &#123;      this.ctx.save();      const &#123;        url,        top = 0,        left = 0,        width = 0,        height = 0,        borderRadius = 0,        deg = 0,      &#125; = params;      if (deg !== 0) &#123;        this.ctx.translate(left + width / 2, top + height / 2);        this.ctx.rotate((deg * Math.PI) / 180);        this.ctx.drawImage(url, -width / 2, -height / 2, width, height);      &#125; else &#123;        this.ctx.beginPath();        this.ctx.arc(left, top, borderRadius, 0, 2 * Math.PI, false);        this.ctx.fillStyle = &quot;#9fd9ef&quot;;        this.ctx.fill();        this.ctx.lineWidth = 1;        this.ctx.strokeStyle = &quot;#00477d&quot;;        this.ctx.stroke();        this.ctx.drawImage(url, left, top, width, height);      &#125;      this.ctx.restore();    &#125;,    drawText(params) &#123;      this.ctx.save();      const &#123;        MaxLineNumber = 2,        breakWord = false,        color = &quot;black&quot;,        content = &quot;&quot;,        fontSize = 16,        top = 0,        left = 0,        lineHeight = 20,        textAlign = &quot;left&quot;,        width,        bolder = false,        textDecoration = &quot;none&quot;,      &#125; = params;      this.ctx.beginPath();      this.ctx.setTextBaseline(&quot;top&quot;);      this.ctx.setTextAlign(textAlign);      this.ctx.setFillStyle(color);      this.ctx.setFontSize(fontSize);      if (!breakWord) &#123;        this.ctx.fillText(content, left, top, width);        this.drawTextLine(left, top, textDecoration, color, fontSize, content);      &#125; else &#123;        let fillText = &quot;&quot;;        let fillTop = top;        let lineNum = 1;        for (let i = 0; i &lt; content.length; i++) &#123;          fillText += [content[i]];          if (this.ctx.measureText(fillText).width &gt; width) &#123;            if (lineNum === MaxLineNumber) &#123;              if (i !== content.length) &#123;                fillText = fillText.substring(0, fillText.length - 1) + &quot;...&quot;;                this.ctx.fillText(fillText, left, fillTop);                this.drawTextLine(                  left,                  fillTop,                  textDecoration,                  color,                  fontSize,                  fillText                );                fillText = &quot;&quot;;                break;              &#125;            &#125;            this.ctx.fillText(fillText, left, fillTop);            this.drawTextLine(              left,              fillTop,              textDecoration,              color,              fontSize,              fillText            );            fillText = &quot;&quot;;            fillTop += lineHeight;            lineNum++;          &#125;        &#125;        this.ctx.fillText(fillText, left, fillTop);        this.drawTextLine(          left,          fillTop,          textDecoration,          color,          fontSize,          fillText        );      &#125;      this.ctx.restore();      if (bolder) &#123;        this.drawText(&#123;          ...params,          left: left + 0.3,          top: top + 0.3,          bolder: false,          textDecoration: &quot;none&quot;,        &#125;);      &#125;    &#125;,    drawTextLine(left, top, textDecoration, color, fontSize, content) &#123;      if (textDecoration === &quot;underline&quot;) &#123;        this.drawRect(&#123;          background: color,          top: top + fontSize * 1.2,          left: left - 1,          width: this.ctx.measureText(content).width + 3,          height: 1,        &#125;);      &#125; else if (textDecoration === &quot;line-through&quot;) &#123;        this.drawRect(&#123;          background: color,          top: top + fontSize * 0.6,          left: left - 1,          width: this.ctx.measureText(content).width + 3,          height: 1,        &#125;);      &#125;    &#125;,    drawRect(params) &#123;      this.ctx.save();      const &#123; background, top = 0, left = 0, width = 0, height = 0 &#125; = params;      this.ctx.setFillStyle(background);      this.ctx.fillRect(left, top, width, height);      this.ctx.restore();    &#125;,    getImageInfo(url) &#123;      return new Promise((resolve, reject) =&gt; &#123;        if (this.cache[url]) &#123;          resolve(this.cache[url]);        &#125; else &#123;          const objExp = new RegExp(            /^http(s)?:\\/\\/([\\w-]+\\.)+[\\w-]+(\\/[\\w- .\\/?%&amp;=]*)?/          );          if (objExp.test(url)) &#123;            uni.getImageInfo(&#123;              src: url,              complete: (res) =&gt; &#123;                if (res.errMsg === &quot;getImageInfo:ok&quot;) &#123;                  this.cache[url] = res.path;                  resolve(res.path);                &#125; else &#123;                  // this.triggerEvent(&#x27;getImage&#x27;, &#123;errMsg: &#x27;canvasdrawer:download fail&#x27;&#125;)                  this.$emit(&quot;getImage&quot;, &#123;                    errMsg: &quot;canvasdrawer:download fail&quot;,                  &#125;);                  reject(new Error(&quot;getImageInfo fail&quot;));                &#125;              &#125;,            &#125;);          &#125; else &#123;            this.cache[url] = url;            resolve(url);          &#125;        &#125;      &#125;);    &#125;,    saveImageToLocal() &#123;      const width = this.width;      const height = this.height;      uni.canvasToTempFilePath(        &#123;          x: 0,          y: 0,          width,          height,          canvasId: this.name,          complete: (res) =&gt; &#123;            if (res.errMsg === &quot;canvasToTempFilePath:ok&quot;) &#123;              this.showCanvas = false;              this.isPainting = false;              this.tempFileList = [];              this.$emit(&quot;getImage&quot;, &#123;                tempFilePath: res.tempFilePath,                errMsg: &quot;canvasdrawer:ok&quot;,              &#125;);            &#125; else &#123;              this.$emit(&quot;getImage&quot;, &#123; errMsg: &quot;canvasdrawer:fail&quot; &#125;);            &#125;          &#125;,        &#125;,        this      );    &#125;,  &#125;,&#125;;&lt;/script&gt;&lt;style&gt;.board &#123;  position: fixed;  top: 2000rpx;&#125;&lt;/style&gt;\n","slug":"Dcloud的Canvas插件二次改写为Vue模板","date":"2021-06-30T16:00:00.000Z","categories_index":"uni-app","tags_index":"uni-app,canvas","author_index":"谢小谢"},{"id":"cbaa866e1d73edd3734c218b3bd40e4c","title":"安卓IOS应用桥接js","content":"记录下自己公司和 js 友商的 APP 桥接的过程 ## 代码展示\n123456789101112131415161718192021222324252627282930313233343536373839404142// 环境判断const isAndroid = navigator.userAgent.indexOf(&#x27;Android&#x27;) &gt; -1 || navigator.userAgent.indexOf(&#x27;Adr&#x27;) &gt; -1;// 初始化桥接function initBridge(callback) &#123;  if (isAndroid) &#123;    /**安卓端创建桥接*/    if (window.WebViewJavascriptBridge) &#123;      callback(WebViewJavascriptBridge);    &#125; else &#123;      document.addEventListener(        &quot;WebViewJavascriptBridgeReady&quot;,        function () &#123;          callback(WebViewJavascriptBridge);        &#125;,        false      );    &#125;  &#125; else &#123;    /**苹果端创建桥接*/    if (window.WebViewJavascriptBridge) &#123;      return callback(WebViewJavascriptBridge);    &#125;    if (window.WVJBCallbacks) &#123;      return window.WVJBCallbacks.push(callback);    &#125;    window.WVJBCallbacks = [callback];    const WVJBIframe = document.createElement(&quot;iframe&quot;);    WVJBIframe.style.display = &quot;none&quot;;    WVJBIframe.src = &quot;wvjbscheme://__BRIDGE_LOADED__&quot;;    document.documentElement.appendChild(WVJBIframe);    setTimeout(function () &#123;      document.documentElement.removeChild(WVJBIframe);    &#125;, 0);  &#125;&#125;initBridge((bridge) =&gt; &#123;  // 调用Native方法  bridge.callHandler(方法名, 参数, (res) =&gt; &#123;...执行对应操作&#125;);  // 注册方法  bridge.registerHandler(方法名, (res) =&gt; &#123;...执行对应操作&#125;);&#125;);\n","slug":"安卓IOS应用桥接js","date":"2021-02-24T16:00:00.000Z","categories_index":"","tags_index":"APP","author_index":"谢小谢"},{"id":"042d33a635bea50f9dee5448c961536b","title":"组件库按需加载声明文件(d.ts)编写","content":"前言自己的 Fat-ui 组件库和 babel 按需加载插件写完之后，也抽空把 d.ts 声明文件一起做了，现在将编写和配置过程记录下来\n第一步 首先分析下 Vue3 插件注册时的部分源代码1234567891011121314151617181920212223// 文件地址： vue-next/packages/runtime-core/src/apiCreateApp.ts// 创建一个存储所有插件的列表const installedPlugins = new Set()// use方法使用插件use(plugin: Plugin, ...options: any[]) &#123; // 如果列表里面已经注册了 那么就提示 if (installedPlugins.has(plugin)) &#123;   __DEV__ &amp;&amp; warn(`Plugin has already been applied to target app.`)  // 如果插件的install是一个函数 那么推入插件列表 并且直接执行install &#125; else if (plugin &amp;&amp; isFunction(plugin.install)) &#123;  installedPlugins.add(plugin)  plugin.install(app, ...options)  // 如果插件是一个函数 那么也是直接执行 因为插件注册有2种方式  // 1.对象里面带install函数  // 2.函数  &#125; else if (isFunction(plugin)) &#123;    installedPlugins.add(plugin)    plugin(app, ...options)  &#125; else if (__DEV__) &#123;  &#125;  return app&#125;\n\n从上图可知插件里面需要注册一个 install 方法\n第二步 首先需要定义全局组件注册的 d.ts1234567index.d.ts import &#123; App &#125; from &#x27;vue&#x27;// 定义了一个classexport class FatComponent &#123;  static name: string// 传入App实例static install: (app: App) =&gt; any &#125;export class button extends FatComponent &#123;&#125;\n\n第三步通过上面的 d.ts 编写后 就可以直接在 package.json 的 typings 指定声明文件的地址了, 声明之后就可以直接打包\n1&#123; &quot;typings&quot;: &quot;types/index.d.ts&quot;,   ... &#125;\n","slug":"组件库按需加载声明文件(d.ts)编写","date":"2021-02-22T16:00:00.000Z","categories_index":"库相关,经验","tags_index":"Vue,组件库","author_index":"谢小谢"},{"id":"5355fae89eaca8d398dfae233dd715c4","title":"定制自己的 Fat-ui 组件库之如何编写自己的按需加载 babel 插件","content":"作为一名前端开发工程师 我一直想拥有自己的一套组件库，最近把 Fat-ui 的几个组件已经完成，现在将之前的按需加载 babel 插件编写过程记录下来\n\n\n\n\n\n\n\n\n\n可以下载我的 babel-plugin-dynamic 库\n查看代码：npm i babel-plugin-dynamic -D\n\n\n\n\n\n\n\n\n\nTip: 对下文不懂的可以参考babel插件入门\n本质按需加载原理其实就是运用 commonjs 单独引入打包后的 js 文件和 css 文件，代码转换如下123// 参照我自己的Fat-ui组件 转换前import &#123; cell &#125; from &quot;fat-ui&quot;;// 转换后var cell = require(&#x27;fat-ui/lib/cell&#x27;)require(&#x27;fat-ui/style/cell.css&#x27;)\n\n了解 babel 编译过程babel 编译过程分为三个阶段：&gt; 源代码 -&gt; AST -&gt; 转换过的 AST -&gt; 转换过的代码\n转换过程对应着几个不同的包,而这些包都包含在@babel&#x2F;core 核心包内\n\n@babel&#x2F;parser：解析 js 代码,转换成 AST 语法\n@babel&#x2F;traverse：遍历 AST 语法，对 AST 进行遍历操作，生成新的 AST\n@babel&#x2F;generator：把 AST 代码转换成 js 代码\n@babel&#x2F;types：提供的一个工具函数来创建一个 AST 节点\n\n开始写代码先看源代码转换成 AST 前后的样子1234567891011121314151617181920212223242526272829303132333435363738394041// 转换前import &#123; cell, dialog &#125; from &#x27;fat-ui&#x27;// 转换后&#123;  type: &quot;Program&quot;,  start: 0,  end: 37,  body: [    &#123;      type: &quot;ImportDeclaration&quot;,      start: 0,      end: 37,      specifiers: [        &#123;          type: &quot;ImportSpecifier&quot;,          start: 9,          end: 13,          imported: &#123; type: &quot;Identifier&quot;, start: 9, end: 13, name: &quot;cell&quot; &#125;,          local: &#123; type: &quot;Identifier&quot;, start: 9, end: 13, name: &quot;cell&quot; &#125;,        &#125;,        &#123;          type: &quot;ImportSpecifier&quot;,          start: 15,          end: 21,          imported: &#123; type: &quot;Identifier&quot;, start: 15, end: 21, name: &quot;dialog&quot; &#125;,          local: &#123; type: &quot;Identifier&quot;, start: 15, end: 21, name: &quot;dialog&quot; &#125;,        &#125;,      ],      source: &#123;        type: &quot;Literal&quot;,        start: 29,        end: 37,        value: &quot;fat-ui&quot;,        raw: &quot;&#x27;fat-ui&#x27;&quot;,      &#125;,    &#125;,  ],  sourceType: &quot;module&quot;,&#125;;\n\n从上图可以分析得出\n\nImportDeclaration：import 语句定义\nImportSpecifier：cell,dialog 括号语句定义\nIdentifier：括号内语句定义内容\nsource 下面的 Literal： 源包名称\n\n根据这一我们可以编写自己的转换逻辑,123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const t = require(&quot;@babel/types&quot;);/*  访问者是一个用于 AST 遍历的跨语言的模式。 简单的说它们就是一个对象，定义了用于在一个树状结构中获取具体节点的方法*/const visitor = &#123;  // 当在树中遇见一个 ImportDeclaration 的时候会调用ImportDeclaration()  ImportDeclaration(path, &#123; opts &#125;) &#123;    const &#123; node &#125; = path;    // babel配置文件时传入的自定义参数    const frameworkName = node.source.value;    let requireStr = [];    // 判断当前框架是否是配置的指定框架 并且节点树的第一个导入是否是模块导入而不是默认导入    if (      frameworkName === opts.frameworkName &amp;&amp;      node.specifiers[0].type === &quot;ImportSpecifier&quot; &amp;&amp;      node.specifiers.map((item) =&gt; t.isImportSpecifier(item))    ) &#123;      node.specifiers.forEach((item, index) =&gt; &#123;        if (index === 0) &#123;        &#125;        // 生成require语句        requireStr.push(          t.VariableDeclaration(&quot;var&quot;, [            t.VariableDeclarator(              t.Identifier(item.imported.name),              t.callExpression(t.identifier(&quot;require&quot;), [                t.stringLiteral(                  `$&#123;frameworkName&#125;/lib/$&#123;item.imported.name.toLowerCase()&#125;`                ),              ])            ),          ])        );        requireStr.push(          t.callExpression(t.identifier(&quot;require&quot;), [            t.stringLiteral(              `$&#123;frameworkName&#125;/lib/style/$&#123;item.imported.name.toLowerCase()&#125;.css`            ),          ])        );      &#125;);      // 替换语句      path.replaceWithMultiple(requireStr);    &#125;  &#125;,&#125;;// 作为一个common.js模块导出module.exports = function () &#123;  return &#123;    // 访问者模 visitor  &#125;;&#125;;\n\npackage.json 发布包1&#123;  ...  &quot;main&quot;: &quot;index.js&quot;,  ...&#125;\n\n使用 babel.config.js 引用1module.exports = &#123; plugins: [[&quot;dynamic&quot;, &#123; frameworkName: &quot;fat-ui&quot; &#125;]] &#125;;\n","slug":"定制自己的 Fat-ui 组件库之如何编写自己的按需加载 babel 插件","date":"2021-02-21T16:00:00.000Z","categories_index":"经验","tags_index":"babel","author_index":"谢小谢"},{"id":"8cb79cbb342e1af117a4deecc4477305","title":"Vue下使用better-scroll触发click事件触发2次的解决方法","content":"最近在做公司项目的时候遇到了一个很奇怪的 bug, 当前页为一个 better-scroll 页面 当跳转到下一个页面再返回再跳转时 一次点击事件触发了 2 次。原因: better-scroll 第二次初始化时第一次的实例未卸载导致\n解决思路 在第二次重新初始化时把 click 配置项改为 false123456789101112export default &#123;  methods: &#123;    _initScroll(bool) &#123;      const _self = this;      _self.listBscroll = new BScroll(&quot;.list-wrapper&quot;, &#123;        probeType: 1,        click: bool,        pullUpLoad: &#123; threshold: -30 &#125;,      &#125;);    &#125;,  &#125;,&#125;;\n","slug":"Vue下使用better-scroll触发click事件触发2次的解决方法2020-09-14","date":"2020-09-13T16:00:00.000Z","categories_index":"Vue,总结","tags_index":"better-scroll","author_index":"谢小谢"},{"id":"3579d33c3390fb8f737ed089f4ee848a","title":"Vue动态组件打包实测","content":"记录一次关于 Vue 动态组件打包的异同\n未使用异步组件的打包情况12345&lt;script&gt;import HelloWorld from &quot;./components/HelloWorld.vue&quot;;import Demo from &quot;./components/demo.vue&quot;;export default &#123; components: &#123; HelloWorld, Demo &#125; &#125;;&lt;/script&gt;\n\n12345678910111213141516File                                 Size               Gzipped  \tdist\\\\js\\\\chunk-vendors.3cdd9400.js    89.10 KiB          31.92 KiB \tdist\\\\js\\\\app.13046f3b.js              7.08 KiB           1.77 KiB \tdist\\\\css\\\\app.1d736950.css            0.51 KiB           0.25 KiB ```## 使用异步组件后的打包情况```js&lt;script&gt;import HelloWorld from &quot;./components/HelloWorld.vue&quot;;import Demo from &quot;./components/demo.vue&quot;;export default &#123; components: &#123;   HelloWorld: () =&gt; import(&quot;./components/HelloWorld.vue&quot;),   Demo: () =&gt; import(&quot;./components/demo.vue&quot;), &#125;,&#125;;&lt;/script&gt;\n\n打包后的文件夹情况\n12345678File                        Size          Gzippeddist\\js\\chunk-vendors.49d7da52.js 89.34 KiB 31.98 KiBdist\\js\\app.71ab26fc.js 4.18 KiB 1.94 KiBdist\\js\\chunk-b3235d12.e2a9d657.js 2.58 KiB 0.79 KiBdist\\js\\chunk-c7bea068.5f268e60.js 2.58 KiB 0.79 KiBdist\\css\\chunk-b3235d12.22b7f024.css 0.17 KiB 0.13 KiBdist\\css\\chunk-c7bea068.0f5084a9.css 0.17 KiB 0.13 KiBdist\\css\\app.6af8ca07.css 0.16 KiB 0.14 KiB\n\n实际区别可以看到, Demo 组件和 HelloWorld 组件被分割了出来, 生成了两个 chunk 文件, 在编写代码逻辑时可以针对这两个组件进行延迟加载, 从而减少首屏的载入时间\n","slug":"Vue动态组件打包实测","date":"2020-09-13T16:00:00.000Z","categories_index":"webpack,总结","tags_index":"webpack","author_index":"谢小谢"},{"id":"baf239d953fd03e4fb1a47a4e7060466","title":"记一次企业微信WX JS-SDK的不同设备下的问题","content":"问题记录: 最近在一次企业微信的 jssdk 的调用过程中发现 IOS 设备下在功能页初始化配置微信 js-sdk 无效。\n解决方法: Android 下获取微信 js-sdk 配置只需传 window.href。 IOS 下传 location.href.split( ‘# ‘)[0] ### 方法封装 #### 对微信 js-sdk 初始化进行配置\n1234567891011121314151617181920212223242526272829import wx from &quot;weixin-js-sdk &quot;;import &#123; getWxJssdk &#125; from &quot;@/api/customer &quot;;/* \t* 判断是否IOS环境 \t* */export function isIOS() &#123;  let isIphone = navigator.userAgent.includes(&quot;iPhone &quot;);  let isIpad = navigator.userAgent.includes(&quot;iPad &quot;);  return isIphone || isIpad;&#125;/** 获取微信签名，注入权限验证配置 \t* */export async function requestWxStr() &#123;  let url = isIOS() ? location.href.split(&quot;# &quot;)[0] : location.href;  var params = &#123; &quot;localUrl &quot;: location.href.split(&quot;# &quot;)[0] &#125;;  try &#123;    let res = await getWxJssdk(&#123; url &#125;);    if (res.signature) &#123;      wx.config(&#123;        beta: true, // 必须这么写，否则wx.invoke调用形式的jsapi会有问题        debug: true,        appId: res.signature.appId,        timestamp: res.signature.timestamp, // 必填，生成签名的时间戳        nonceStr: res.signature.nonceStr, // 必填，生成签名的随机串        signature: res.signature.signature, // 必填，签名，见 附录-JS-SDK使用权限签名算法        jsApiList: [&quot;onMenuShareWechat &quot;, &quot;shareWechatMessage &quot;],      &#125;);    &#125;  &#125; catch (e) &#123;    throw e;  &#125;&#125;\n\n路由初始化时判断设备类型进行配置1234567router.beforeEach((to, from, next) =&gt; &#123;  if (isIOS()) &#123;    if (from.path === &quot;/&quot;) &#123;      requestWxStr(); //该函数和之前一样，被单独提取出来了    &#125;  &#125;&#125;);\n\n功能页如果不是 IOS 页面就初始化12345created() &#123;  if (!isIOS()) &#123;    requestWxStr();  &#125;&#125;\n\n1\n","slug":"记一次企业微信WX JS-SDK的不同设备下的问题","date":"2020-09-13T16:00:00.000Z","categories_index":"经验","tags_index":"canvas,js-sdk","author_index":"谢小谢"},{"id":"977046a105528b08c6104c9e8e95e023","title":"HTTP缓存机制记录","content":"http 缓存机制很容易就忘记了 这里大概记录一下\n简单概括http 缓存分为强缓存(Cache-Control &gt; Expires),协商缓存(Etag &#x2F; If-None-Match &gt; Last-Modified &#x2F; If-Modified-Since)强缓存和协商缓存的区别&gt; 强缓存命中的情况下不和服务器做交互，协商缓存不管有没有命中都会和服务器做交互\n第一次请求\n浏览器发起 http 请求到服务器。\nhttp 请求通过浏览器缓存，浏览器缓存没有发现该请求的缓存标识和缓存结果，会直接放行，让 http 请求直接请求到服务器。\n服务器返回请求结果和缓存规则给浏览器\n浏览器将请求结果和缓存标识存入浏览器缓存中，作为下一次请求的标识\n\n第二次请求命中强缓存的情况\nExpires 该字段作为缓存标志， 如果客户端的时间小于 Expires 的值时，就直接使用缓存结果，但是这只是存在于 HTTP&#x2F;1.0 中，现今大部分已经被 Cache-Control 所替代\nCache-Control HTTP1.1 所使用的标识，该字段有以下几种属性\npublic：所有内容都将被缓存（客户端和代理服务器都可缓存）\nprivate：所有内容只有客户端可以缓存，Cache-Control 的默认取值\nno-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定\nno-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存\nmax-age&#x3D;xxx (xxx is numeric)：缓存内容将在 xxx 秒后失效\n\n第二次请求\n强缓存未命中，协商缓存命中的情况当协商缓存命中时，服务器返回 304 状态码表示该资源没有更新协商缓存字段有 Last-Modified &#x2F; If-Modified-Since 和 Etag &#x2F; If-None-Match，其中 Etag &#x2F; If-None-Match 的优先级比 Last-Modified &#x2F; If-Modified-Since 高。\nIf-None-Match&#x2F;Etag &#x3D;&gt; 客户端再次发起该请求时，携带上次请求返回的唯一标识 Etag 值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有 If-None-Match，则会根据 If-None-Match 的字段值与该资源在服务器的 Etag 值做对比，一致则返回 304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，返回 200\nLast-Modified&#x2F;If-Modified-Since &#x3D;&gt; 则是客户端再次发起该请求时，携带上次请求返回的 Last-Modified 值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有 If-Modified-Since 字段，则会根据 If-Modified-Since 的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于 If-Modified-Since 的字段值，则重新返回资源，状态码为 200；否则则返回 304，代表资源无更新，可继续使用缓存文件\n\n","slug":"HTTP缓存机制记录","date":"2019-12-03T16:00:00.000Z","categories_index":"http,总结","tags_index":"http","author_index":"谢小谢"},{"id":"f88c08d2432ee83789750b7f28e6e54e","title":"DockerCompose一键配置nginx,mysql环境","content":"之前一直觉得把 mysql 和 nginx 环境分别分开部署很不好，一旦服务器宕机，又得找到对应的目录开启对应的指令，后面发现了 docker 可以用来一次性部署环境，但是也有缺点，服务器宕机的情况下 Mysql 容器里面的数据就会丢失，正好 docker-compose 可以解决这个问题，在这里记录下自己的部署过程。\n前期准备docker 环境安装(这部分自行百度)安装完毕就直接拉取镜像\n\n\n\n\n\n\n\n\n\ndocker pull mysql:5.6docker pull nginx:latest\n开始正式配置docker-compose.yml 在自己配置好的 docker 文件夹下(推荐)，创建 docker-compose.yml\n\n\n\n\n\n\n\n\n\ntouch docker-compose.yml 编辑 docker-compose.ymlvim docker-compose.yml 粘贴配置文件\n123456789101112131415nginx:  image: nginx:latest  ports:    - \\&quot;80:80\\&quot;  volumes:    - ./nginx/conf/nginx.conf:/etc/nginx/nginx.conf:ro  mysql:  restart: always  image: mysql:5.6  volumes:    - ./mysql:/var/lib/mysql  ports:    - 3306:3306  environment:   MYSQL_ROOT_PASSWORD: \\&quot;your_mysql_password\\&quot;\n\n说明: _ image 代表所要启动的镜像名称_ ports 为当前镜像所启动的映射端口* volumes 下方配置 分号左边为本地的路径，分号右边为原始配置路径，即使用当前路径替换原始配置路径达到自定义的效果* MYSQL_ROOT_PASSWORD 为初始化的 mysql 密码之前后就可以在当前目录下创建 mysql 文件夹和 nginx 文件夹，nginx 文件夹下创建 conf 文件夹并在 conf 下创建 nginx.conf 配置文件\n开始配置nginx.conf 文件这里需要注意 upstream 里面的域名不能直接使用 localhost&#x2F;127.0.0.1 因为 docker 下是无法访问外部宿主机 需要使用指令桥接替换本地 ip 指向，输入以下指令就可以直接使用 192.168.0.1 来指代本地 ip\n\n\n\n\n\n\n\n\n\ndocker network create -d bridge –subnet 192.168.0.0&#x2F;24 –gateway 192.168.0.1 localNet\n开始构建 docker 容器在 docker 文件夹下输入构建指令\n\n\n\n\n\n\n\n\ndocker-compose up -d\n如果提示如下，那么就成功构建   docker_mysql_1 is up-to-date  docker_nginx_1 is up-to-date构建完直接开启服务\n\n\n\n\n\n\n\n\n\ndocker-compose start &#x2F;&#x2F; 开启服务\n","slug":"DockerCompose一键配置nginx,mysql环境","date":"2019-12-02T16:00:00.000Z","categories_index":"docker部署","tags_index":"nginx,docker","author_index":"谢小谢"},{"id":"e7f5e465a1dcc0e0547db7a3cbc7589e","title":"如何在Linux环境部署Node.js环境","content":"博客即将部署, 在这里记录下自己 node 环境的配置方法\n第一步进入Node 官网下载页，chrome 按下 F12 进入控制台，点击元素获取下载连接\\n 或者也可以通过 QQ 浏览器自带的下载器,点击右键提取下载链接\n第二步使用 Centos(或者其他 linux 服务器)的 wget 命令，如果没有 wget 命令就使用自带的 yum 命令下载 wget(如下)&gt; yum install -y wget 下载完 wget 之后就可以直接下载 Node&gt; wget https://npm.taobao.org/mirrors/node/v12.13.1/node-v12.13.1-linux-x64.tar.xz\n第三步使用 tar 命令解压安装包&gt; tar -xvf node-v12.13.1-linux-x64.tar.xz\n第四步直接使用软连接方式全局配置 Node 和 npm js\\nln -s /usr/local/nodejs/bin/npm /usr/local/bin/\\nln -s /usr/local/nodejs/bin/node /usr/local/bin/\\n\n第五步控制台直接 node -v 或者 npm -v 打印 Node 版本\n","slug":"如何在Linux环境部署Node.js环境","date":"2019-12-02T16:00:00.000Z","categories_index":"经验","tags_index":"linux","author_index":"谢小谢"},{"id":"c56ee70c55fbd1ff18b7573952b52a52","title":"CSS多行溢出处理","content":"前言之前做过的布局文字溢出效果 一段时间不用之后就老是忘记 今天记录下来\n单行溢出123overflow: hidden;text-overflow: ellipsis;white-space: nowrap;\n\n多行溢出(webkit)1234overflow: hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-line-clamp: 2; // 在第几行处省略-webkit-box-orient: vertical;\n","slug":"CSS多行溢出处理","date":"2019-10-02T16:00:00.000Z","categories_index":"CSS样式","tags_index":"CSS,SCSS","author_index":"谢小谢"}]